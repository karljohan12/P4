import java_cup.runtime.*;


parser code  {:
  public void report_error(String message, Object info) {
    StringBuilder m = new StringBuilder("Error ");

    if (info instanceof java_cup.runtime.Symbol)
      m.append( "("+info.toString()+")" );

    m.append(" : "+message);

    System.out.println(m);
  }

  public void report_fatal_error(String message, Object info) {
    report_error(message, info);
    throw new RuntimeException("Fatal Syntax Error");
  }
:};

terminal BOOLEAN; // primitive_type
terminal INT; // integral_type
terminal DOUBLE; // floating_point_type
terminal LBRACE, RBRACE, LBRACK, RBRACK; // array_type
terminal DOT; // qualified_name
terminal SEMICOLON, MULT, COMMA, EQ, LPAREN, RPAREN, COLON;
terminal BEGIN;
terminal END;
terminal VOID; // method_header
terminal DEFAULT;
terminal IF, ELSE; // if_then_statement, if_then_else_statement
terminal SWITCH; // switch_statement
terminal CASE; // switch_label
terminal WHILE; // while_statement, do_statement
terminal FOR; // for_statement
terminal BREAK; // break_statement
terminal RETURN; // return_statement
terminal PLUSPLUS; // postincrement_expression
terminal MINUSMINUS; // postdecrement_expression
terminal PLUS, MINUS, COMP, NOT, DIV, MOD;
terminal LT, GT, LTEQ, GTEQ; // relational_expression
terminal EQEQ, NOTEQ; // equality_expression
terminal ANDAND; // conditional_and_expression
terminal OROR; // conditional_or_expression
terminal QUESTION; // conditional_expression
terminal MULTEQ, DIVEQ, MODEQ, PLUSEQ, MINUSEQ; // assignment_operator
terminal WHEN, THEN;
terminal AND, OR;
terminal ROBOT, SERVOPOSITION, SERVO;
terminal DELAY;

terminal java.lang.Number INTEGER_LITERAL;
terminal java.lang.Number FLOATING_POINT_LITERAL;
terminal java.lang.Boolean BOOLEAN_LITERAL;
terminal java.lang.String IDENTIFIER; // name
terminal java.lang.String STRING_LITERAL; //string
terminal NULL_LITERAL;

// strictfp keyword, new in Java 1.2

// Reserved but unused:
terminal CONST;

// 19.2) The Syntactic Grammar
non terminal program;
// 19.3) Lexical Structure
non terminal literal;
// 19.4) Types, Values, and Variables
non terminal type, primitive_type, numeric_type;
non terminal integral_type, floating_point_type;
non terminal reference_type;
non terminal array_type;
// 19.5) Names
non terminal name, simple_name, qualified_name;
// 19.6) Packages
non terminal compilation_unit;
non terminal method_statements;
// 19.7) Productions used only in the LALR(1) grammar
// 19.8.2) Field Declarations
non terminal variable_declarators, variable_declarator;
non terminal variable_declarator_id, variable_initializer;
// 19.8.3) Method Declarations
non terminal method_declaration, method_header, method_declarator;
non terminal formal_parameter_list_opt, formal_parameter_list;
non terminal formal_parameter;
non terminal method_body;
// 19.10) Arrays
non terminal array_initializer;
non terminal variable_initializers;
// 19.11) Blocks and Statements
non terminal block;
non terminal block_statements_opt, block_statements, block_statement;
non terminal local_variable_declaration_statement, local_variable_declaration;
non terminal statement, statement_no_short_if;
non terminal statement_without_trailing_substatement;
non terminal empty_statement;
non terminal expression_statement, statement_expression;
non terminal if_then_statement;
non terminal if_then_else_statement, if_then_else_statement_no_short_if;
non terminal switch_statement, switch_block;
non terminal switch_block_statement_groups;
non terminal switch_block_statement_group;
non terminal switch_labels, switch_label;
non terminal while_statement, while_statement_no_short_if;
non terminal for_statement, for_statement_no_short_if;
non terminal for_init_opt, for_init;
non terminal for_update_opt, for_update;
non terminal statement_expression_list;
non terminal identifier_opt;
non terminal break_statement, continue_statement;
non terminal return_statement;
// 19.12) Expressions
non terminal primary, primary_no_new_array;
non terminal argument_list_opt, argument_list;
non terminal array_creation_expression;
non terminal dim_exprs, dim_expr, dims_opt, dims;
non terminal field_access, method_invocation, array_access;
non terminal postfix_expression;
non terminal postincrement_expression, postdecrement_expression;
non terminal unary_expression, unary_expression_not_plus_minus;
non terminal preincrement_expression, predecrement_expression;
non terminal multiplicative_expression, additive_expression;
non terminal relational_expression, equality_expression;
non terminal conditional_and_expression, conditional_or_expression;
non terminal conditional_expression, assignment_expression;
non terminal assignment;
non terminal left_hand_side;
non terminal assignment_operator;
non terminal expression_opt, expression;
non terminal constant_expression;
non terminal global_variable;
non terminal global_variables;
non terminal method_statements_opt;
non terminal servo_type;
non terminal servo_initializer;
non terminal servo_initializers;
non terminal robot_type;
non terminal delay_initializer;

start with program;


// 19.2) The Syntactic Grammar
program ::=	compilation_unit:cu //{:RESULT = new Program(cu);:}
	;

// 19.3) Lexical Structure.
literal ::=	INTEGER_LITERAL
	|	FLOATING_POINT_LITERAL
	|	BOOLEAN_LITERAL
	|	NULL_LITERAL
    |	STRING_LITERAL
	;

// 19.4) Types, Values, and Variables
type	::=	primitive_type
	|	reference_type
	;
primitive_type ::=
		numeric_type
	|   SERVO
	|	BOOLEAN
	;
numeric_type::=	integral_type
	|	floating_point_type
	;
integral_type ::=
	INT
	;
floating_point_type ::=
	DOUBLE
	;

reference_type ::=  array_type
    | robot_type
    | servo_type
    | name
	;

servo_type ::= SERVOPOSITION;

robot_type ::= ROBOT;



array_type ::=	primitive_type dims
	|	name dims
	;

// 19.5) Names
name	::=	simple_name
	|	qualified_name
	;
simple_name ::=	IDENTIFIER
	;
qualified_name ::=
		name DOT IDENTIFIER
	;

// 19.6) Packages
compilation_unit ::= global_variables:gl method_statements_opt:mso //{:RESULT = new Compilation_unit(gl, mso);:}
    | method_statements_opt;


global_variables ::= global_variable
    | global_variables global_variable
    ;


global_variable ::= local_variable_declaration_statement;

method_statements_opt ::= method_statements | ;

method_statements ::=
        method_declaration
    |   method_statements method_declaration
    ;

variable_declarators ::=
	    variable_declarator
	|	variable_declarators COMMA variable_declarator
	;
variable_declarator ::=
		variable_declarator_id
	|	variable_declarator_id EQ variable_initializer
	;
variable_declarator_id ::=
		IDENTIFIER
	|	variable_declarator_id LBRACK RBRACK
	;
variable_initializer ::=
		expression
	|	array_initializer
	|   servo_initializer
	;

// 19.8.3) Method Declarations
method_declaration ::=
		method_header method_body
	;
method_header ::=
	    type method_declarator
	|	VOID method_declarator
	;
method_declarator ::=
		IDENTIFIER LPAREN formal_parameter_list_opt RPAREN
	|	method_declarator LBRACK RBRACK // deprecated
	// be careful; the above production also allows 'void foo() []'
	;
formal_parameter_list_opt ::=
	|	formal_parameter_list
	;
formal_parameter_list ::=
		formal_parameter
	|	formal_parameter_list COMMA formal_parameter
	;
formal_parameter ::=
		type variable_declarator_id
	|	CONST type variable_declarator_id
	;

method_body ::=	block
	|	SEMICOLON
	;

// 19.10) Arrays
array_initializer ::=
		LBRACE variable_initializers COMMA RBRACE
	|	LBRACE variable_initializers RBRACE
	|	LBRACE COMMA RBRACE
	|	LBRACE RBRACE
	;

servo_initializers ::= IDENTIFIER COLON literal
    |   servo_initializers COMMA IDENTIFIER COLON literal
    ;

servo_initializer ::=
        LBRACE servo_initializers RBRACE
    ;

variable_initializers ::=
		variable_initializer
	|	variable_initializers COMMA variable_initializer
	;

// 19.11) Blocks and Statements
block ::=	BEGIN block_statements_opt END
	;
block_statements_opt ::=
	|	block_statements
	;
block_statements ::=
		block_statement
	|	block_statements block_statement
	;
block_statement ::=
		local_variable_declaration_statement
	|	statement
	;
local_variable_declaration_statement ::=
		local_variable_declaration SEMICOLON
	;
local_variable_declaration ::=
		type variable_declarators
	|	CONST type variable_declarators
	;
statement ::=
        statement_without_trailing_substatement
	|	if_then_statement
	|	if_then_else_statement
	|	while_statement
	|	for_statement
	;
statement_no_short_if ::=
		statement_without_trailing_substatement
	|	if_then_else_statement_no_short_if
	|	while_statement_no_short_if
	|	for_statement_no_short_if
	;
statement_without_trailing_substatement ::=
		block
	|	empty_statement
	|	expression_statement
	|	switch_statement
	|	break_statement
	|	continue_statement
	|	return_statement
	;
empty_statement ::=
		SEMICOLON
	;

expression_statement ::=
		statement_expression SEMICOLON
	;
statement_expression ::=
		assignment
	|	preincrement_expression
	|	predecrement_expression
	|	postincrement_expression
	|	postdecrement_expression
	|	method_invocation
	;
if_then_statement ::=
		IF LPAREN expression RPAREN statement
	;
if_then_else_statement ::=
		IF LPAREN expression RPAREN statement_no_short_if
			ELSE statement
	;
if_then_else_statement_no_short_if ::=
		IF LPAREN expression RPAREN statement_no_short_if
			ELSE statement_no_short_if
	;
switch_statement ::=
		SWITCH LPAREN expression RPAREN switch_block
	;
switch_block ::=
		BEGIN switch_block_statement_groups switch_labels END
	|	BEGIN switch_block_statement_groups END
	|	BEGIN switch_labels END
	|	BEGIN END
	;
switch_block_statement_groups ::=
		switch_block_statement_group
	|	switch_block_statement_groups switch_block_statement_group
	;
switch_block_statement_group ::=
		switch_labels block_statements
	;
switch_labels ::=
		switch_label
	|	switch_labels switch_label
	;
switch_label ::=
		CASE constant_expression COLON
	|	DEFAULT COLON
	;

while_statement ::=
		WHILE LPAREN expression RPAREN statement
	;
while_statement_no_short_if ::=
		WHILE LPAREN expression RPAREN statement_no_short_if
	;

for_statement ::=
		FOR LPAREN for_init_opt WHEN expression_opt THEN
			for_update_opt RPAREN statement
	;
for_statement_no_short_if ::=
		FOR LPAREN for_init_opt WHEN expression_opt THEN
			for_update_opt RPAREN statement_no_short_if
	;
for_init_opt ::=
	|	for_init
	;
for_init ::=	statement_expression_list
	|	local_variable_declaration
	;
for_update_opt ::=
	|	for_update
	;
for_update ::=	statement_expression_list
	;
statement_expression_list ::=
		statement_expression
	|	statement_expression_list COMMA statement_expression
	;

identifier_opt ::=
	|	IDENTIFIER
	;

break_statement ::=
		BREAK identifier_opt SEMICOLON
	;

return_statement ::=
		RETURN expression_opt SEMICOLON
	;

// 19.12) Expressions
primary ::=	primary_no_new_array
	|	array_creation_expression
	;
primary_no_new_array ::=
		literal
	|	LPAREN expression RPAREN
	|	field_access
	|	method_invocation
	|	array_access
	;

argument_list_opt ::=
	|	argument_list
	;
argument_list ::=
		expression
	|	argument_list COMMA expression
	;
array_creation_expression ::=
		 primitive_type dim_exprs dims_opt
	|	 primitive_type dims array_initializer
	;
dim_exprs ::=	dim_expr
	|	dim_exprs dim_expr
	;
dim_expr ::=	LBRACK expression RBRACK
	;
dims_opt ::=
	|	dims
	;
dims ::=	LBRACK RBRACK
	|	dims LBRACK RBRACK
	;
field_access ::=
		primary DOT IDENTIFIER
	;
method_invocation ::=
		name LPAREN argument_list_opt RPAREN
	;
array_access ::=
		name LBRACK expression RBRACK
	|	primary_no_new_array LBRACK expression RBRACK
	;
postfix_expression ::=
		primary
	|	name
	|	postincrement_expression
	|	postdecrement_expression
	;
postincrement_expression ::=
		postfix_expression PLUSPLUS
	;
postdecrement_expression ::=
		postfix_expression MINUSMINUS
	;
unary_expression ::=
		preincrement_expression
	|	predecrement_expression
	|	PLUS unary_expression
	|	MINUS unary_expression
	|	unary_expression_not_plus_minus
	;
preincrement_expression ::=
		PLUSPLUS unary_expression
	;
predecrement_expression ::=
		MINUSMINUS unary_expression
	;
unary_expression_not_plus_minus ::=
		postfix_expression
	|	COMP unary_expression
	|	NOT unary_expression
	;

multiplicative_expression ::=
		unary_expression
	|	multiplicative_expression MULT unary_expression
	|	multiplicative_expression DIV unary_expression
	|	multiplicative_expression MOD unary_expression
	;
additive_expression ::=
		multiplicative_expression
	|	additive_expression PLUS multiplicative_expression
	|	additive_expression MINUS multiplicative_expression
	;

relational_expression ::=
		additive_expression
	|	relational_expression LT additive_expression
	|	relational_expression GT additive_expression
	|	relational_expression LTEQ additive_expression
	|	relational_expression GTEQ additive_expression
	;
equality_expression ::=
		relational_expression
	|	equality_expression EQEQ relational_expression
	|	equality_expression NOTEQ relational_expression
	;

conditional_and_expression ::=
		equality_expression
	|	conditional_and_expression ANDAND equality_expression
	;
conditional_or_expression ::=
		conditional_and_expression
	|	conditional_or_expression OROR conditional_and_expression
	;
conditional_expression ::=
		conditional_or_expression
	|	conditional_or_expression QUESTION expression
			COLON conditional_expression
	;
assignment_expression ::=
		conditional_expression
	|	assignment
	;
assignment ::=	left_hand_side assignment_operator assignment_expression
	;
left_hand_side ::=
		name
	|	field_access
	|	array_access
	;
assignment_operator ::=
		EQ
	|	MULTEQ
	|	DIVEQ
	|	MODEQ
	|	PLUSEQ
	|	MINUSEQ
	;
expression_opt ::=
	|	expression
	;
expression ::=	assignment_expression
	;
constant_expression ::=
		expression
	;
