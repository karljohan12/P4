import java_cup.runtime.*;


parser code  {:
  public void report_error(String message, Object info) {
    StringBuilder m = new StringBuilder("Error ");

    if (info instanceof java_cup.runtime.Symbol)
      m.append( "("+info.toString()+")" );

    m.append(" : "+message);

    System.out.println(m);
  }

  public void report_fatal_error(String message, Object info) {
    report_error(message, info);
    throw new RuntimeException("Fatal Syntax Error");
  }
:};

terminal BOOLEAN;
terminal INT;
terminal DOUBLE;
terminal CONST;
terminal LBRACE, RBRACE, LBRACK, RBRACK;
terminal SEMICOLON, MULT, COMMA, EQ, LPAREN, RPAREN, COLON;
terminal BEGIN;
terminal END;
terminal VOID;
terminal DEFAULT;
terminal IF, ELSE;
terminal SWITCH;
terminal CASE;
terminal WHILE;
terminal FOR;
terminal BREAK;
terminal RETURN;
terminal PLUSPLUS;
terminal MINUSMINUS;
terminal PLUS, MINUS, COMP, NOT, DIV, MOD;
terminal LT, GT, LTEQ, GTEQ;
terminal EQEQ, NOTEQ;
terminal ANDAND;
terminal OROR;
terminal QUESTION;
terminal MULTEQ, DIVEQ, MODEQ, PLUSEQ, MINUSEQ;
terminal WHEN, THEN;
terminal ROBOT, SERVOPOSITION, SERVO;

terminal java.lang.Number INTEGER_LITERAL;
terminal java.lang.Number FLOATING_POINT_LITERAL;
terminal java.lang.Boolean BOOLEAN_LITERAL;
terminal java.lang.String IDENTIFIER;
terminal java.lang.String STRING_LITERAL;
terminal NULL_LITERAL;



non terminal program;
non terminal literal;


non terminal type, primitiveType, numericType;
non terminal integerType, floatType;
non terminal referenceType;
non terminal arrayType;

non terminal name;
non terminal Start;
non terminal functionStmts;

non terminal variableDecls, variableDecl;
non terminal variableDeclId, variableInit;

non terminal functionDecl, functionHeader, functionDeclerator;
non terminal formalParamListOpt, formalParamList;
non terminal formalParam;
non terminal functionBody;

non terminal arrayInit;
non terminal variableInits;

non terminal block;
non terminal blockStmtsOpt, blockStmts, blockStmt;
non terminal localVariableDeclStmt, localVariableDecl;
non terminal stmt, stmtIfWithoutElse;
non terminal stmtWithoutTrailingSubstatement;
non terminal emptyStmt;
non terminal exprStmt, stmtExpr;
non terminal ifThenStmt;
non terminal ifThenElseStmt, ifThenElseIfWithoutElse;
non terminal switchStmt, switchBlock;
non terminal switchBlockStmtGroups;
non terminal switchBlockStmtGroup;
non terminal switchLabels, switchLabel;
non terminal whileStmt;
non terminal forStmt;
non terminal forInit;
non terminal stmtExprList;
non terminal breakStmt, continueStatement;
non terminal returnStmt;

non terminal primary, primaryNoNewArray;
non terminal argumentListOpt, argumentList;
non terminal arrayCreationExpr;
non terminal bracketEnclosureExprs, bracketEnclosureExpr, bracketEnclosureOpt, bracketEnclosure;
non terminal functionCall, arrayAccess;
non terminal postfixExpr;
non terminal postincrementExpr, postdecrementExpr;
non terminal unaryExpr, unaryExprNotPlusMinus;
non terminal preincrementExpr, predecrementExpr;
non terminal mulExpr, plusExpr;
non terminal relationalExpr, equalExpr;
non terminal conditionalAndExpr, conditionalOrExpr;
non terminal conditionalExpr, assignmentExpr;
non terminal assignment;
non terminal leftHandSide;
non terminal assignmentOperator;
non terminal expr;
non terminal constantExpr;
non terminal globalVariable;
non terminal globalVariables;
non terminal functionStmtsOpt;
non terminal servoType;
non terminal servoInit;
non terminal servoInits;
non terminal robotType;


start with program;


program ::=	Start:cu
	;

literal ::=	INTEGER_LITERAL
            {:RESULT =:}
	|	FLOATING_POINT_LITERAL
	{:RESULT =:}
	|	BOOLEAN_LITERAL
	{:RESULT =:}
	|	NULL_LITERAL
	{:RESULT =:}
    |	STRING_LITERAL
    {:RESULT =:}
	;

type	::=	primitiveType
            {:RESULT =:}
	|	referenceType
	{:RESULT =:}
	;
primitiveType ::=
		numericType
		{:RESULT =:}
	|   SERVO
	{:RESULT =:}
	|	BOOLEAN
	{:RESULT =:}
	;
numericType::=
    integerType
    {:RESULT =:}
	|	floatType
	{:RESULT =:}
	;
integerType ::=
	INT
	{:RESULT =:}
	;
floatType ::=
	DOUBLE
	{:RESULT =:}
	;

referenceType ::=
    arrayType
    {:RESULT =:}
    | robotType
    {:RESULT =:}
    | servoType
    {:RESULT =:}
    | name
    {:RESULT =:}
	;

servoType ::=
    SERVOPOSITION
    {:RESULT =:};

robotType ::=
    ROBOT
    {:RESULT =:};

arrayType ::=
    primitiveType bracketEnclosure
    {:RESULT =:}
	|	name bracketEnclosure
	{:RESULT =:}
	;

name	::=
    IDENTIFIER
    {:RESULT =:}

	;

Start ::=
    globalVariables:gl functionStmtsOpt:mso
    {:RESULT =:}
    | functionStmtsOpt;
    {:RESULT =:}


globalVariables ::=
    globalVariable
    {:RESULT =:}
    | globalVariables globalVariable
    {:RESULT =:}
    ;

globalVariable ::=
    localVariableDeclStmt;
    {:RESULT =:}

functionStmtsOpt ::=
    functionStmts
    {:RESULT =:}
    | ;

functionStmts ::=
    functionDecl
    {:RESULT =:}
    |   functionStmts functionDecl
    {:RESULT =:}
    ;

variableDecls ::=
     variableDecl
     {:RESULT =:}
	 |	variableDecls COMMA variableDecl
	 {:RESULT =:}
	;
variableDecl ::=
     variableDeclId
	 {:RESULT =:}
	 |	variableDeclId EQ variableInit
	 {:RESULT =:}
	;
variableDeclId ::=
	 IDENTIFIER
	 {:RESULT =:}
	 |	variableDeclId LBRACK RBRACK
	 {:RESULT =:}
	;
variableInit ::=
		expr
		{:RESULT =:}
	    |	arrayInit
	    {:RESULT =:}
	    |   servoInit
	    {:RESULT =:}
	;

functionDecl ::=
		functionHeader functionBody
		{:RESULT =:}
	;
functionHeader ::=
	    type functionDeclerator
	    {:RESULT =:}
	    | 	VOID functionDeclerator
	    {:RESULT =:}
	;
functionDeclerator ::=
		IDENTIFIER LPAREN formalParamListOpt RPAREN
		{:RESULT =:}
	    |	functionDeclerator LBRACK RBRACK
	    {:RESULT =:}
	;
formalParamListOpt ::=
	|	formalParamList
	{:RESULT =:}
	;
formalParamList ::=
		formalParam
		{:RESULT =:}
     	|	formalParamList COMMA formalParam
    	{:RESULT =:}
	;
formalParam ::=
		type variableDeclId
		{:RESULT =:}
	    |	CONST type variableDeclId
	    {:RESULT =:}
	;

functionBody ::=
        block
        {:RESULT =:}
	    |	SEMICOLON
	    {:RESULT =:}
	;

arrayInit ::=
		LBRACE variableInits COMMA RBRACE
		{:RESULT =:}
	|	LBRACE variableInits RBRACE
	{:RESULT =:}
	|	LBRACE COMMA RBRACE
	{:RESULT =:}
	|	LBRACE RBRACE
	{:RESULT =:}
	;

servoInits ::=
    IDENTIFIER COLON literal
    {:RESULT =:}
    |   servoInits COMMA IDENTIFIER COLON literal
    {:RESULT =:}
    ;

servoInit ::=
        LBRACE servoInits RBRACE
        {:RESULT =:}
    ;

variableInits ::=
		variableInit
		{:RESULT =:}
	|	variableInits COMMA variableInit
	{:RESULT =:}
	;

block ::=
    BEGIN blockStmtsOpt END
    {:RESULT =:}
	;

blockStmtsOpt ::=
	|	blockStmts
	{:RESULT =:}
	;

blockStmts ::=
		blockStmt
		{:RESULT =:}
	|	blockStmts blockStmt
	{:RESULT =:}
	;

blockStmt ::=
		localVariableDeclStmt
		{:RESULT =:}
	|	stmt
	{:RESULT =:}
	;

localVariableDeclStmt ::=
		localVariableDecl SEMICOLON
		{:RESULT =:}
	;

localVariableDecl ::=
		type variableDecls
		{:RESULT =:}
	|	CONST type variableDecls
	{:RESULT =:}
	;

stmt ::=
        stmtWithoutTrailingSubstatement
        {:RESULT =:}
	|	ifThenStmt
	{:RESULT =:}
	|	ifThenElseStmt
	{:RESULT =:}
	|	whileStmt
	{:RESULT =:}
	|	forStmt
	{:RESULT =:}
	;

stmtIfWithoutElse ::=
		stmtWithoutTrailingSubstatement
		{:RESULT =:}
	|	ifThenElseIfWithoutElse
	{:RESULT =:}
	;

stmtWithoutTrailingSubstatement ::=
		block
		{:RESULT =:}
	|	emptyStmt
	{:RESULT =:}
	|	exprStmt
	{:RESULT =:}
	|	switchStmt
	{:RESULT =:}
	|	breakStmt
	{:RESULT =:}
	|	continueStatement
	{:RESULT =:}
	|	returnStmt
	{:RESULT =:}
	;

emptyStmt ::=
		SEMICOLON
		{:RESULT =:}
	;

exprStmt ::=
		stmtExpr SEMICOLON
		{:RESULT =:}
	;

stmtExpr ::=
		assignment
		{:RESULT =:}
	|	preincrementExpr
	{:RESULT =:}
	|	predecrementExpr
	{:RESULT =:}
	|	postincrementExpr
	{:RESULT =:}
	|	postdecrementExpr
	{:RESULT =:}
	|	functionCall
	{:RESULT =:}
	;

ifThenStmt ::=
		IF LPAREN expr RPAREN stmt
		{:RESULT =:}
	;

ifThenElseStmt ::=
		IF LPAREN expr RPAREN stmtIfWithoutElse
			ELSE stmt
			{:RESULT =:}
	;

ifThenElseIfWithoutElse ::=
		IF LPAREN expr RPAREN stmtIfWithoutElse
			ELSE stmtIfWithoutElse
			{:RESULT =:}
	;

switchStmt ::=
		SWITCH LPAREN expr RPAREN switchBlock
		{:RESULT =:}
	;

switchBlock ::=
		BEGIN switchBlockStmtGroups switchLabels END
		{:RESULT =:}
	|	BEGIN switchBlockStmtGroups END
	{:RESULT =:}
	|	BEGIN switchLabels END
	{:RESULT =:}
	|	BEGIN END
	{:RESULT =:}
	;

switchBlockStmtGroups ::=
		switchBlockStmtGroup
		{:RESULT =:}
	|	switchBlockStmtGroups switchBlockStmtGroup
	{:RESULT =:}
	;

switchBlockStmtGroup ::=
		switchLabels blockStmts
		{:RESULT =:}
	;

switchLabels ::=
		switchLabel
		{:RESULT =:}
	|	switchLabels switchLabel
	{:RESULT =:}
	;

switchLabel ::=
		CASE constantExpr COLON
		{:RESULT =:}
	|	DEFAULT COLON
	{:RESULT =:}
	;

whileStmt ::=
		WHILE LPAREN expr RPAREN
		{:RESULT =:}
	;

forStmt ::=
		FOR LPAREN forInit WHEN expr THEN
			stmtExprList RPAREN
			{:RESULT =:}
	;

forInit ::=
        stmtExprList
        {:RESULT =:}
	        |	localVariableDecl
	        {:RESULT =:}
	;

stmtExprList ::=
		stmtExpr
		{:RESULT =:}
	        |	stmtExprList COMMA stmtExpr
	        {:RESULT =:}
	;

breakStmt ::=
		BREAK SEMICOLON
		{:RESULT =:}
	;

returnStmt ::=
		RETURN expr SEMICOLON
		{:RESULT =:}
	;

primary ::=
        primaryNoNewArray
        {:RESULT =:}
	        |	arrayCreationExpr
	        {:RESULT =:}
	;
primaryNoNewArray ::=
		literal
		{:RESULT =:}
	|	LPAREN expr RPAREN
	{:RESULT =:}
	|	functionCall
	{:RESULT =:}
	|	arrayAccess
	{:RESULT =:}
	;

argumentListOpt ::=
	|	argumentList
	{:RESULT =:}
	;

argumentList ::=
		expr
		{:RESULT =:}
	|	argumentList COMMA expr
	{:RESULT =:}
	;

arrayCreationExpr ::=
		 primitiveType bracketEnclosureExprs bracketEnclosureOpt
		 {:RESULT =:}
	|	 primitiveType bracketEnclosure arrayInit
	{:RESULT =:}
	;

bracketEnclosureExprs ::=
        bracketEnclosureExpr
        {:RESULT =:}
	|	bracketEnclosureExprs bracketEnclosureExpr
	{:RESULT =:}
	;

bracketEnclosureExpr ::=	LBRACK expr RBRACK
        {:RESULT =:}
	;

bracketEnclosureOpt ::=
	|	bracketEnclosure
	    {:RESULT =:}
	;

bracketEnclosure ::=	LBRACK RBRACK
        {:RESULT =:}
	|	bracketEnclosure LBRACK RBRACK
	    {:RESULT =:}
	;

functionCall ::=
		name LPAREN argumentListOpt RPAREN
		{:RESULT =:}
	;

arrayAccess ::=
		name LBRACK expr RBRACK
		{:RESULT =:}
	    |	primaryNoNewArray LBRACK expr RBRACK
	    {:RESULT =:}
	;

postfixExpr ::=
		primary
		{:RESULT =:}
	|	name
	{:RESULT =:}
	|	postincrementExpr
	{:RESULT =:}
	|	postdecrementExpr
	{:RESULT =:}
	;

postincrementExpr ::=
		postfixExpr PLUSPLUS
		{:RESULT =:}
	;

postdecrementExpr ::=
		postfixExpr MINUSMINUS
		{:RESULT =:}
	;

unaryExpr ::=
		preincrementExpr
		{:RESULT =:}
	|	predecrementExpr
	{:RESULT =:}
	|	PLUS unaryExpr
	{:RESULT =:}
	|	MINUS unaryExpr
	{:RESULT =:}
	|	unaryExprNotPlusMinus
	{:RESULT =:}
	;

preincrementExpr ::=
		PLUSPLUS unaryExpr
		{:RESULT =:}
	;

predecrementExpr ::=
		MINUSMINUS unaryExpr
		{:RESULT =:}
	;

unaryExprNotPlusMinus ::=
		postfixExpr
		{:RESULT =:}
	|	COMP unaryExpr
	{:RESULT =:}
	|	NOT unaryExpr
	{:RESULT =:}
	;

mulExpr ::=
		unaryExpr
		{:RESULT =:}
	|	mulExpr MULT unaryExpr
	{:RESULT =:}
	|	mulExpr DIV unaryExpr
	{:RESULT =:}
	|	mulExpr MOD unaryExpr
	{:RESULT =:}
	;
plusExpr ::=
		mulExpr
		{:RESULT =:}
	|	plusExpr PLUS mulExpr
	{:RESULT =:}
	|	plusExpr MINUS mulExpr
	{:RESULT =:}
	;

relationalExpr ::=
		plusExpr
		{:RESULT =:}
	|	relationalExpr LT plusExpr
	{:RESULT =:}
	|	relationalExpr GT plusExpr
	{:RESULT =:}
	|	relationalExpr LTEQ plusExpr
	{:RESULT =:}
	|	relationalExpr GTEQ plusExpr
	{:RESULT =:}
	;

equalExpr ::=
		relationalExpr
		{:RESULT =:}
	|	equalExpr EQEQ relationalExpr
	{:RESULT =:}
	|	equalExpr NOTEQ relationalExpr
	{:RESULT =:}
	;

conditionalAndExpr ::=
		equalExpr
    {:RESULT =:}
	|	conditionalAndExpr ANDAND equalExpr
	{:RESULT =:}
	;

conditionalOrExpr ::=
		conditionalAndExpr
		{:RESULT =:}
	|	conditionalOrExpr OROR conditionalAndExpr
	{:RESULT =:}
	;

conditionalExpr ::=
		conditionalOrExpr
		{:RESULT =:}
	|	conditionalOrExpr QUESTION expr
			COLON conditionalExpr
			{:RESULT =:}
	;

assignmentExpr ::=
		conditionalExpr
		{:RESULT =:}
	|	assignment
	{:RESULT =:}
	;

assignment ::=	leftHandSide assignmentOperator assignmentExpr
    {:RESULT =:}
	;

leftHandSide ::=
		name
		{:RESULT =:}
	|	arrayAccess
	{:RESULT =:}
	;

expr ::=	assignmentExpr
    {:RESULT =:}
	;

assignmentOperator ::=
		EQ
		{:RESULT =:}
	|	MULTEQ
	{:RESULT =:}
	|	DIVEQ
	{:RESULT =:}
	|	MODEQ
	{:RESULT =:}
	|	PLUSEQ
	{:RESULT =:}
	|	MINUSEQ
	{:RESULT =:}
	;

constantExpr ::=
		expr
		{:RESULT =:}
	;

