import java_cup.runtime.*;

parser code  {:
  public void report_error(String message, Object info) {
    StringBuilder m = new StringBuilder("Error ");

    if (info instanceof java_cup.runtime.Symbol)
      m.append( "("+info.toString()+")" );

    m.append(" : "+message);

    System.out.println(m);
  }

  public void report_fatal_error(String message, Object info) {
    report_error(message, info);
    throw new RuntimeException("Fatal Syntax Error");
  }
:};

terminal BOOLEAN;
terminal INT;
terminal DOUBLE;
terminal CONST;
terminal LBRACE, RBRACE, LBRACK, RBRACK;
terminal SEMICOLON, MULT, COMMA, EQ, LPAREN, RPAREN, COLON;
terminal BEGIN;
terminal END;
terminal VOID;
terminal DEFAULT;
terminal IF, ELSE;
terminal SWITCH;
terminal CASE;
terminal WHILE;
terminal FOR;
terminal BREAK;
terminal RETURN;
terminal PLUSPLUS;
terminal MINUSMINUS;
terminal PLUS, MINUS, COMP, NOT, DIV, MOD;
terminal LT, GT, LTEQ, GTEQ;
terminal EQEQ, NOTEQ;
terminal ANDAND;
terminal OROR;
terminal QUESTION;
terminal MULTEQ, DIVEQ, MODEQ, PLUSEQ, MINUSEQ;
terminal WHEN, THEN;
terminal ROBOT, SERVOPOSITION, SERVO;

terminal java.lang.Number INTEGER_LITERAL;
terminal java.lang.Number FLOATING_POINT_LITERAL;
terminal java.lang.Boolean BOOLEAN_LITERAL;
terminal java.lang.String IDENTIFIER;
terminal java.lang.String STRING_LITERAL;
terminal NULL_LITERAL;



non terminal Program program;
non terminal literal;


non terminal type, primitiveType, numericType;
non terminal integerType, floatType;
non terminal referenceType;
non terminal arrayType;

non terminal name;
non terminal Start;
non terminal functionStmts;

non terminal variableDecls, variableDecl;
non terminal variableDeclId, variableInit;

non terminal functionDecl, functionHeader, functionDeclerator;
non terminal formalParamListOpt, formalParamList;
non terminal formalParam;
non terminal functionBody;

non terminal arrayInit;
non terminal variableInits;

non terminal block;
non terminal blockStmtsOpt, blockStmts, blockStmt;
non terminal localVariableDeclStmt, localVariableDecl;
non terminal stmt, stmtIfWithoutElse;
non terminal stmtWithoutTrailingSubstatement;
non terminal emptyStmt;
non terminal exprStmt, stmtExpr;
non terminal ifThenStmt;
non terminal ifThenElseStmt, ifThenElseIfWithoutElse;
non terminal switchStmt, switchBlock;
non terminal switchBlockStmtGroups;
non terminal switchBlockStmtGroup;
non terminal switchLabels, switchLabel;
non terminal whileStmt;
non terminal forStmt;
non terminal forInit;
non terminal stmtExprList;
non terminal breakStmt, continueStatement;
non terminal returnStmt;

non terminal primary, primaryNoNewArray;
non terminal argumentListOpt, argumentList;
non terminal arrayCreationExpr;
non terminal bracketEnclosureExprs, bracketEnclosureExpr, bracketEnclosureOpt, bracketEnclosure;
non terminal functionCall, arrayAccess;
non terminal postfixExpr;
non terminal postincrementExpr, postdecrementExpr;
non terminal unaryExpr, unaryExprNotPlusMinus;
non terminal preincrementExpr, predecrementExpr;
non terminal mulExpr, plusExpr;
non terminal relationalExpr, equalExpr;
non terminal conditionalAndExpr, conditionalOrExpr;
non terminal conditionalExpr, assignmentExpr;
non terminal assignment;
non terminal leftHandSide;
non terminal assignmentOperator;
non terminal expr;
non terminal constantExpr;
non terminal globalVariable;
non terminal globalVariables;
non terminal functionStmtsOpt;
non terminal servoType;
non terminal servoInit;
non terminal servoInits;
non terminal robotType;


start with program;


program                         ::=	Start:s
                                      {: RESULT = new Program(s, sleft); :};

literal                         ::=	INTEGER_LITERAL:intLit
                                      {: RESULT = new IntegerLiteral(intLit, intLitleft); :}
	                              |	FLOATING_POINT_LITERAL:floatLit
	                                  {: RESULT = new FloatLiteral(floatLit, floatLitleft); :}
	                              |	BOOLEAN_LITERAL:boolLit
	                                  {: RESULT =new BoolLiteral(boolLit, boolLitleft); :}
	                              |	NULL_LITERAL: nullLit
	                                  {: RESULT =new NullLiteral(nullLit, nullLitleft); :}
                                  |	STRING_LITERAL:strLit
                                      {: RESULT = new StrLiteral(strLit, strLitleft); :};

type	                        ::=	primitiveType:primType
                                      {: RESULT = new PrimitiveType(primType, primTypeleft); :}
	                              |	referenceType:refType
	                                  {: RESULT = new ReferenceType(refType, refTypeleft); :};

primitiveType                   ::= numericType:numType
	                            	  {: RESULT = new NumericType(numType, numTypeleft); :}
	                              | SERVO:servoType
	                                  {: RESULT = new ServoType(servoType, servoTypeleft); :}
	                              |	BOOLEAN:boolType
	                                  {: RESULT = new BoolType(boolType, boolTypeleft); :};

numericType                     ::= INT:intType
                                      {: RESULT = new IntType(intType, intTypeleft); :}
	                              |	DOUBLE:floatType
	                                  {: RESULT = new FloatType(floatType, floatTypeleft); :};

referenceType                   ::= arrayType:arrType
                                      {: RESULT = new ArrayType(arrType, arrTypeleft); :}
                                  | ROBOT:robotType
                                      {: RESULT = new robotType(robotType, robotTypeleft); :}
                                  | SERVOPOSITION:servoType
                                      {: RESULT = new ServoType(servoType, servoTypeleft); :}
                                  | name:nameType
                                      {: RESULT = new Name(nameType, nameTypeleft); :};

arrayType                       ::= primitiveType:primType bracketEnclosure:brackEnc
                                      {: RESULT = new PrimTypeBrackEnc(primType, brackEnc, primTypeleft);:}
                                  |	name:nameType bracketEnclosure:brackEnc
	                                  {: RESULT = new NameTypeBrackEnc(nameType, brackEnc, nameTypeleft); :};

name	                        ::= IDENTIFIER:ident
                                      {: RESULT = new Ident(ident, identleft); :};

Start                           ::= globalVariables:gvs functionStmtsOpt:funcStmtOpt
                                      {: RESULT = new GlobalVarfuncStmtOpt(gvs, funcStmtOpt, gvsleft); :}
                                  | functionStmtsOpt: funcStmtOpt
                                      {: RESULT = new FuncStmtOpt(funcstmtOpt, funcStmtOptleft); :};


globalVariables                 ::= globalVariable:gv
                                      {: RESULT = new GlobalVaribale(gv, gvleft); :}
                                  | globalVariables:gvs globalVariable:gv
                                      {: RESULT = new GlobalVariables(gvs, gv, gvsleft); :};

globalVariable                  ::=  localVariableDeclStmt:lvds
                                       {: RESULT = new localVariableDeclStmt(lvds, lvdsleft); :};

functionStmtsOpt                ::= functionStmts:fs
                                      {:RESULT = new Function(fs, fsleft);:}
                                  | ;

functionStmts                   ::= functionDecl:fd
                                      {: RESULT = new FunctionDecl(fd, fdleft); :}
                                  | functionStmts:fs functionDecl:fd
                                      {: RESULT = new FunctionStmtsFunctionDecl(fs, fd, fsleft); :};

variableDecls                   ::= variableDecl:vd
                                      {: RESULT = new VariableDecl(vd, vdleft); :}
	                              |	variableDecls:vds COMMA variableDecl:vd
	                                  {: RESULT = new variableDeclsVariableDecl(vds, vd, vdsleft); :};

variableDecl                    ::= variableDeclId:vdi
	                                  {: RESULT = new VariableDeclId(vdi, vdileft); :}
	                              |	variableDeclId:vdi EQ variableInit:vi
	                                  {: RESULT = new VariableDeclIdVariableInit(vdi, vi); :};

variableDeclId                  ::= IDENTIFIER:ident
	                                  {: RESULT = new Ident(ident, identleft); :}
	                              |	variableDeclId:vdi LBRACK RBRACK
	                                  {: RESULT = new variableDecIDBrackBrack(vdi, vdileft); :};

variableInit                    ::= expr:exp
		                              {: RESULT = new expr(exp, expleft); :}
	                              |	arrayInit:ai
	                                  {: RESULT = new ArrayInit(ai, aileft); :}
	                              |   servoInit:si
	                                    {:RESULT = new ServoInit(si, sileft); :};

functionDecl                    ::= functionHeader:fh functionBody:fb
		                              {: RESULT = new FunctionHeaderBody(fh, fb, fhleft); :};

functionHeader                  ::= type:t functionDeclerator:fd
	                                  {:RESULT = new TypeFunctionDeclerator(fd, fdleft); :}
	                              | VOID functionDeclerator:fd
	                                  {:RESULT = new voidFunctionDeclerator(fd, fdleft); :};

functionDeclerator              ::= IDENTIFIER LPAREN formalParamListOpt:fplo RPAREN
		                              {: RESULT = new FunctionDeclerator(fplo, fploleft); :}
	                              |	functionDeclerator:fd LBRACK RBRACK
	                                  {: RESULT = new FunctionDecleratorBrack(fd, fdleft); :};

formalParamListOpt              ::=
	                              |	formalParamList:fpl
	                                  {: RESULT = new FormalParamList(fpl, fplleft); :};

formalParamList                 ::= formalParam:fp
		                              {: RESULT = new FormalParam(fp, fpleft);:}
     	                          | formalParamList:fpl COMMA formalParam:fp
    	                              {:RESULT = new FormalParamListFormalParam(fpl, fp, fplleft);:}
	;
formalParam                     ::= type:t variableDeclId:vdi
		                              {: RESULT = new TypeVariableDelcId(t, vdi, tleft); :}
	                              | CONST type:t variableDeclId:vdi
	                                  {: RESULT = new ConstTypeVariableDelcId(t, vdi, tleft); :};

functionBody                    ::= block:b
                                      {: RESULT = new Block(b, bleft); :}
	                              |	SEMICOLON:sc
	                                  {: RESULT = new SemiColon(scleft); :};

arrayInit                       ::= LBRACE variableInits:vi COMMA RBRACE
		                              {: RESULT = new VariableInitsComma(vi, vilift); :}
	                              |	LBRACE variableInits:vi RBRACE
	                                  {: RESULT = new VariableInitsBracks(vi, vilift); :}
	                              |	LBRACE:lb COMMA RBRACE
	                                  {: RESULT = new LBraceCommaRBrace(lbleft); :}
	                              |	LBRACE:lb RBRACE
	                                  {: RESULT = new LBRACERBRACE(lbleft); :};

servoInits                      ::= IDENTIFIER COLON literal:l
                                      {: RESULT = new Literal(l, left); :}
                                  | servoInits:si COMMA IDENTIFIER COLON literal:l
                                      {: RESULT = new ServoInitLiteral(si, l, sileft); :};

servoInit                       ::= LBRACE servoInits:si RBRACE
                                      {: RESULT = new ServoInits(si, sileft); :};

variableInits                   ::= variableInit:vi
		                              {: RESULT = new  VariableInit(vi, vileft); :}
	                              |	variableInits:vis COMMA variableInit:vi
	                                  {: RESULT = new VariableInitsInit(vis, vi, visleft); :};

block                           ::= BEGIN blockStmtsOpt:bso END
                                      {: RESULT = new BlockStmtsOpt(bso, bsoleft); :};

blockStmtsOpt                   ::=
	                              |	blockStmts:bss
	                                  {: RESULT = new BlockStmts(bss, bssleft); :};

blockStmts                      ::= blockStmt:bs
		                              {: RESULT = new BlockStmt(bs, bsleft); :}
	                              |	blockStmts:bss blockStmt:bs
                                      {: RESULT = new BlockStmtstmt(bss, bs, bssleft); :};

blockStmt                       ::= localVariableDeclStmt:lvds
		                              {: RESULT = new localVariableDeclStmt(lvds, lvdsleft);:}
	                              |	stmt:s
	                                  {: RESULT = new stmt(s, sleft); :};

localVariableDeclStmt           ::= localVariableDecl:lvd SEMICOLON
		                              {: RESULT = LocalVariableDecl(lvd, lvdleft); :};

localVariableDecl               ::= type:t variableDecls:vds
		                              {: RESULT = new VariableDecls(vds, vdsleft); :}
	                              |	CONST type:t variableDecls:vds
	                                  {:RESULT = new TypeVariableDecls(t, vds, tleft); :};

stmt                            ::= stmtWithoutTrailingSubstatement:swtss
                                      {: RESULT = new StmtWithoutTrailingSubstatement(swtss, swtssleft); :}
	                              |	ifThenStmt:its
	                                  {: RESULT = new IfThenStmt(its, itsleft); :}
	                              |	ifThenElseStmt:ites
	                                  {: RESULT = new IfThenElseStmt(ites, itesleft); :}
	                              |	whileStmt:ws
	                                  {: RESULT = new WhileStmt(ws, wsleft); :}
	                              |	forStmt:fs
	                                  {: RESULT = new ForStmt(fs, fsleft); :};

stmtIfWithoutElse               ::= stmtWithoutTrailingSubstatement:swtss
		                              {: RESULT = new StmtWithoutTrailingSubstatement(swtss, swtssleft); :} // same as 361
	                              |	ifThenElseIfWithoutElse:iteiwe
	                                  {: RESULT = new IfThenElseIfWithoutElse(iteiwe, iteiweleft); :};

stmtWithoutTrailingSubstatement ::= block:b
		                              {: RESULT = new Block(b, bleft); :}
	                              |	emptyStmt:es
	                                  {: RESULT = new Emptystmt(es, esleft); :}
	                              |	exprStmt:exs
	                                  {: RESULT = new ExprStmt(exs, exsleft); :}
	                              |	switchStmt:ss
	                                  {: RESULT = new SwitchStmt(ss, ssleft); :}
	                              |	breakStmt:breaks
	                                  {: RESULT = new breakstmt(breaks, breaksleft); :}
	                              |	continueStatement:cs
	                                  {: RESULT = new ContinueStatement(cs, csleft); :}
	                              |	returnStmt:rs
	                                  {: RESULT = new ReturnStmt(rs, rsleft); :};

emptyStmt               ::= SEMICOLON:SC
		                      {: RESULT = new Semicolon(scleft); :};

exprStmt                ::= stmtExpr:se SEMICOLON
		                      {: RESULT = new StmtExpr(se, seleft); :};

stmtExpr                ::= assignment:a
		                      {: RESULT =  new Assignment(a, aleft); :}
	                      |	preincrementExpr:pie
	                          {: RESULT = new PreIncrementExpr(pie, pieleft); :}
	                      |	predecrementExpr:pde
	                          {: RESULT = new PreDecrementExpr(pde, pdeleft); :}
	                      |	postincrementExpr:post
	                          {: RESULT = new PostincrementExpr(post, postleft); :}
                          |	postdecrementExpr:pode
	                          {: RESULT = new PostdecrementExpr(pode, podeleft); :}
	                      |	functionCall:fc
	                          {: RESULT = new FunctionCall(fc, fcleft); :};

ifThenStmt              ::= IF LPAREN expr:e RPAREN stmt:s
		                      {:RESULT =new IfLparenExprRparen(e, s, eleft);:};

ifThenElseStmt          ::= IF LPAREN expr:e RPAREN stmtIfWithoutElse:siwe ELSE stmt:s
			                  {: RESULT = new IfLparenExprRparenStmtIfWithoutElseElseStmt(e, siwe, s, eleft); :};

ifThenElseIfWithoutElse ::= IF LPAREN expr:e RPAREN stmtIfWithoutElse:siwe ELSE stmtIfWithoutElse:siwe
			                  {: RESULT = new IfLparenExprRparenStmtWithoutElseElseStmtIfWithoutElse(e, siwe, siwe, eleft); :};

switchStmt              ::= SWITCH LPAREN expr:e RPAREN switchBlock:sb
		                      {: RESULT = new Switch(e, sb, eleft); :};

switchBlock             ::= BEGIN switchBlockStmtGroups:sbsgs switchLabels:sl END
		                      {: RESULT = new SwitchBlockLabels(sbsgs, sl, sbsgsleft); :}
	                      |	BEGIN switchBlockStmtGroups:sbsgs END
	                          {: RESULT = new SwitchGroups(sbsgs, sbsglseft); :}
	                      |	BEGIN switchLabels:sls END
	                          {: RESULT = new SwitchLabels(sls, slsleft); :}
	                      |	BEGIN:b END
	                          {: RESULT = new Beginings(bleft); :};

switchBlockStmtGroups   ::= switchBlockStmtGroup:sbsg
		                      {: RESULT = new SwitchBlockGroup(sbsg, sbsgleft);:}
	                      |	switchBlockStmtGroups:sbsgs switchBlockStmtGroup:sbsg
	                          {: RESULT = new switchBlockSwitchBlock(sbsgs, sbsg, sbsgsleft); :};

switchBlockStmtGroup    ::= switchLabels:sls blockStmts:bs
		                      {: RESULT = new SwitchLabelBlock(sls, bs, slsleft); :};

switchLabels            ::= switchLabel:sl
		                      {: RESULT = SwitchLabel(sl, slleft); :}
	                      |	switchLabels:sls switchLabel:sl
	                          {: RESULT = SwisLabelsLabel(sls, sl, slsleft); :};

switchLabel             ::= CASE constantExpr:cs COLON
		                      {: RESULT = ConstExpr(cs, csleft); :}
	                      |	DEFAULT:def COLON
	                          {: RESULT = DEF(defleft);:};

whileStmt               ::= WHILE LPAREN expr:e RPAREN
		                      {: RESULT = WhileExpr(e, eleft); :};

forStmt                 ::= FOR LPAREN forInit:fi WHEN expr:e THEN stmtExprList:sel RPAREN
			                  {: RESULT = ForExpr(fi, e, sel, fileft); :};

forInit                 ::= stmtExprList:sel
                              {:RESULT = StmtExprList(sel, selleft);:}
	                      |	localVariableDecl:lvd
	                          {:RESULT =localVariableDecl(lvd, lvdleft);:};

stmtExprList            ::= stmtExpr:se
		                      {:RESULT = stExpr(se, seleft);:}
	                      |	stmtExprList:sel COMMA stmtExpr:se
	                          {:RESULT = StmtExprListStmtExpr(sel, se, selleft);:};

breakStmt               ::= BREAK:breaks SEMICOLON
		                      {:RESULT = Breakings(breaksleft);:};

returnStmt              ::= RETURN expr:e SEMICOLON
		                      {:RESULT = ReturnStmt(e, eleft);:};

primary                 ::= primaryNoNewArray:pnna
                              {:RESULT = PrimaryNoNewArr(pnna, pnnaleft);:}
	                      |	arrayCreationExpr:ace
	                          {:RESULT = ArrCreate(ace, aceleft);:};
	                          
primaryNoNewArray       ::= literal:l 
                              {: RESULT = new Litaral(l, lleft);:}
	                      |	LPAREN expr:e RPAREN
	                          {: RESULT = new LeftParenthesisExpressionRightParenthesis(e, eleft); :}
	                      |	functionCall:fc
	                          {: RESULT = new FunctionCall(fc, fcleft); :}
	                      |	arrayAccess:aa
	                          {: RESULT = new ArrayAccess(aa, aaleft); :};

argumentListOpt         ::=
	                      |	argumentList:al
	                          {: RESULT = new ArgumentList(al, alleft);:};

argumentList            ::= expr:e
		                      {: RESULT = new Expression(e, eleft); :}
	                      |	argumentList:al COMMA expr:e
	                          {: RESULT = new ArgumentListCommaExpression(al, e, alleft); :};

arrayCreationExpr       ::= primitiveType:pt bracketEnclosureExprs:bee bracketEnclosureOpt:beo
		                      {: RESULT = new PrimitiveTypeBracketEnclosureExpressionsBracketEnclosureOptional(pt, bee, beo, ptleft); :}
	                      |	primitiveType:pt bracketEnclosure:be arrayInit:ai
	                          {: RESULT = new PrimitiveTypeBracketEnclosureArrayInit(pt, be, ai, ptleft); :};

bracketEnclosureExprs   ::= bracketEnclosureExpr:bee
                              {: RESULT = new BracketEnclosureExpression(bee, beeleft); :}
	                      |	bracketEnclosureExprs:bees bracketEnclosureExpr:bee
	                          {: RESULT = new BracketEnclosureExprsExpr(bees, bee, beesleft); :};

bracketEnclosureExpr    ::= LBRACK expr:e RBRACK
                              {: RESULT = LbrackexprRbrack(e, eleft); :};

bracketEnclosureOpt     ::=
	                      |	bracketEnclosure:be
	                          {:RESULT = BracketEnc(be, beleft);:};

bracketEnclosure        ::= LBRACK:lb RBRACK
                              {:RESULT = LbrackRbrack(lbleft);:}
	                      |	bracketEnclosure:be LBRACK RBRACK
	                          {:RESULT = BracketEnclosureBrack(be, beleft);:};

functionCall            ::= name:n LPAREN argumentListOpt:alo RPAREN
		                      {: RESULT = new NameLeftParenthesisArgumentListOptionalRightParenthesis(n, alo, nleft); :};

arrayAccess             ::= name:n LBRACK expr:e RBRACK
		                      {: RESULT = new NameLeftBracketExpressionRightBracket(n, e, nleft); :}
	                      |	primaryNoNewArray:pnna LBRACK expr:e RBRACK
	                          {: RESULT = new PrimaryNoNewArrayLeftBracketExpressionRightBracket(pnna, e, pnnaleft); :};

postfixExpr             ::= primary:p
	                          {: RESULT = new Primary(p, pleft); :}
	                      |	name:n
	                          {: RESULT = new Name(n, nleft); :}
	                      |	postincrementExpr:pie
	                          {: RESULT = new PostIncrementExpression(pie, pieleft); :}
	                      |	postdecrementExpr:pde
	                          {: RESULT = new PostDecrementExpression(pde, pdeleft); :};

postincrementExpr       ::= postfixExpr:pe PLUSPLUS
		                      {: RESULT = new postfixExpressionPlusPlus(pe, peleft); :};

postdecrementExpr       ::= postfixExpr:pe MINUSMINUS
                              {: RESULT = new PostfixExpressionMinusMinus(pe, peleft); :};

unaryExpr               ::= preincrementExpr:pe
		                      {: RESULT = new PreIncrementExpression(pe, peleft); :}
	                      |	predecrementExpr:ue
	                          {: RESULT = new PredecrementExpression(ue, ueleft); :}
	                      |	PLUS unaryExpr:ue
	                          {: RESULT = new PlusUnaryExpression(ue, ueleft); :}
	                      |	MINUS unaryExpr:ue
	                          {: RESULT = new aryExpression(ue, ueleft); :}
	                      |	unaryExprNotPlusMinus:uenpm
	                          {: RESULT = new UnaryExpreonNotPlusMinus(uenpm, uenpmleft); :};

preincrementExpr        ::= PLUSPLUS unaryExpr:ue
		                      {: RESULT = new PlusPlusUnaryExpression(ue, ueleft); :};

predecrementExpr        ::= MINUSMINUS unaryExpr:ue
		                      {: RESULT = new MinusMinusUnaryExpression(ue, ueleft); :};

unaryExprNotPlusMinus   ::= postfixExpr:pe
		                      {: RESULT = new PostfixExpression(pe, peleft); :}
	                      |	COMP unaryExpr:ue
	                          {: RESULT = new ComparableUnaryExpression(ue, ueleft); :}
	                      |	NOT unaryExpr:ue
	                          {: RESULT = new NotUnaryExpression(ue, ueleft); :};

mulExpr                 ::= unaryExpr:ue
		                      {: RESULT = new UnaryExpression(ue, ueleft); :}
	                      |	mulExpr:me MULT unaryExpr:ue
	                          {: RESULT = new MultiplicationExpressionMultiplicationUnaryExpression(me, ue, meleft); :}
	                      |	mulExpr:me DIV unaryExpr:ue
	                          {: RESULT = new MultiplicationExpresionDivisionUnaryExpression(me, ue, meleft); :}
	                      |	mulExpr:me MOD unaryExpr:ue
	                          {: RESULT = new MultiplicationExpressionModuloUnaryExpression(me, ue, meleft); :};

plusExpr                ::= mulExpr:me
	                          {: RESULT = new MultipicationExpression(me, meleft); :}
	                      |	plusExpr:pe PLUS mulExpr:me
	                          {: RESULT = new PlusExpressionPlusMultiplicationExpression(pe, me, peleft); :}
	                      |	plusExpr:pe MINUS mulExpr:me
	                          {: RESULT = new PlusExpressionMinusMtiplicationExpression(pe, me, peleft); :};

relationalExpr          ::= plusExpr:pe
		                      {: RESULT = new PlusExpression(pe, peleft); :}
	                      |	relationalExpr:re LT plusExpr:pe
	                          {: RESULT = new LessThan(re, pe, releft); :}
	                      |	relationalExpr:re GT plusExpr:pe
	                          {: RESULT = new GreaterThan(re, pe, releft); :}
	                      |	relationalExpr:re LTEQ plusExpr:pe
	                          {: RESULT = new LessThanEqual(re, pe, releft); :}
	                      |	relationalExpr:re GTEQ plusExpr:pe
	                          {: RESULT = new GreaterThanEqual(re, pe, releft); :};

equalExpr               ::= relationalExpr:re
		                      {: RESULT = new RelationExpression(re, releft); :}
	                      |	equalExpr:ee EQEQ relationalExpr:re
	                          {: RESULT = new EqualEqualExpression(ee, re, eeleft); :}
	                      |	equalExpr:ee NOTEQ relationalExpr:re
	                          {: RESULT = new NotEqualExpression(ee, re, eeleft); :};

conditionalAndExpr      ::= equalExpr:ee
                              {: RESULT = new EqualExpression(ee, eeleft); :}
	                      |	conditionalAndExpr:cae ANDAND equalExpr:ee
	                          {: RESULT = new ConditionalAndAndExpression(cae, ee, caeleft); :};

conditionalOrExpr       ::= conditionalAndExpr:cae
		                      {: RESULT = new ConditionalAndExpression(cae, caeleft); :}
	                      |	conditionalOrExpr:coe OROR conditionalAndExpr:cae
	                          {: RESULT = new ConditionalOrExprOrOrConditionalAndExpr(coe, cae, coeleft) ;:};

conditionalExpr         ::= conditionalOrExpr:coe
                              {: RESULT = new ConditionalOrExpression(coe, coeleft); :}
	                      | conditionalOrExpr:coe QUESTION expr:e COLON conditionalExpr:ce
			                  {: RESULT = new TernaryExpression(coe, e, ce, coeleft); :};

assignmentExpr          ::= conditionalExpr:ce
		                      {: RESULT = new ConditionalExpression(ce, celeft); :}
	                      | assignment:a
	                          {: RESULT = new AssignmentExpression(a, aleft); :};

assignment              ::=	leftHandSide:lhs assignmentOperator:ao assignmentExpr:ae
                              {: RESULT =  new Assignment(lhs, ao, ae, lhsleft); :};

leftHandSide            ::= name:n
		                      {: RESULT = new Name(n, nleft); :}
	                      |	arrayAccess:aa
	                          {: RESULT = new ArrayAccess(aa, aaleft); :};

expr                    ::=	assignmentExpr:ae
                          {: RESULT = new AssignmentExpression(ae, aeleft); :};

assignmentOperator      ::= EQ:eq
		                      {: RESULT = new Equal(eqleft); :}
	                      |	PLUSEQ:pe
	                          {: RESULT = new PlusEqual(peleft); :}
	                      |	MINUSEQ:me
	                          {: RESULT = new MinusEqueal(meleft); :};

constantExpr        ::= expr:e
		                  {: RESULT = new Expression(e, eleft); :};

