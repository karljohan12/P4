import java_cup.runtime.*;


parser code  {:
  public void report_error(String message, Object info) {
    StringBuilder m = new StringBuilder("Error ");

    if (info instanceof java_cup.runtime.Symbol)
      m.append( "("+info.toString()+")" );

    m.append(" : "+message);

    System.out.println(m);
  }

  public void report_fatal_error(String message, Object info) {
    report_error(message, info);
    throw new RuntimeException("Fatal Syntax Error");
  }
:};

terminal BOOLEAN;
terminal INT;
terminal DOUBLE;
terminal CONST;
terminal LBRACE, RBRACE, LBRACK, RBRACK;
terminal DOT;
terminal SEMICOLON, MULT, COMMA, EQ, LPAREN, RPAREN, COLON;
terminal BEGIN;
terminal END;
terminal VOID;
terminal DEFAULT;
terminal IF, ELSE;
terminal SWITCH;
terminal CASE;
terminal WHILE;
terminal FOR;
terminal BREAK;
terminal RETURN;
terminal PLUSPLUS;
terminal MINUSMINUS;
terminal PLUS, MINUS, COMP, NOT, DIV, MOD;
terminal LT, GT, LTEQ, GTEQ;
terminal EQEQ, NOTEQ;
terminal ANDAND;
terminal OROR;
terminal QUESTION;
terminal MULTEQ, DIVEQ, MODEQ, PLUSEQ, MINUSEQ;
terminal WHEN, THEN;
terminal AND, OR;
terminal ROBOT, SERVOPOSITION, SERVO;
terminal DELAY;

terminal java.lang.Number INTEGER_LITERAL;
terminal java.lang.Number FLOATING_POINT_LITERAL;
terminal java.lang.Boolean BOOLEAN_LITERAL;
terminal java.lang.String IDENTIFIER;
terminal java.lang.String STRING_LITERAL;
terminal NULL_LITERAL;



non terminal program;
non terminal literal;


non terminal type, primitiveType, numericType;
non terminal integralType, floatingPointType;
non terminal referenceType;
non terminal arrayType;

non terminal name, simpleName, qualifiedName;
non terminal compilationUnit;
non terminal methodStatements;

non terminal variableDeclarators, variableDeclarator;
non terminal variableDeclaratorId, variableInitializer;

non terminal methodDeclaration, methodHeader, methodDeclarator;
non terminal formalParameterListOpt, formalParameterList;
non terminal formalParameter;
non terminal methodBody;

non terminal arrayInitializer;
non terminal variableInitializers;

non terminal block;
non terminal blockStatementsOpt, blockStatements, blockStatement;
non terminal localVariableDeclarationStatement, localVariableDeclaration;
non terminal statement, statementNoShortIf;
non terminal statementWithoutTrailingSubstatement;
non terminal emptyStatement;
non terminal expressionStatement, statementExpression;
non terminal ifThenStatement;
non terminal ifThenElseStatement, ifThenElseStatementNoShortIf;
non terminal switchStatement, switchBlock;
non terminal switchBlockStatementGroups;
non terminal switchBlockStatementGroup;
non terminal switchLabels, switchLabel;
non terminal whileStatement, whileStatementNoShortIf;
non terminal forStatement, forStatementNoShortIf;
non terminal forInitOpt, forInit;
non terminal forUpdateOpt, forUpdate;
non terminal statementExpressionList;
non terminal identifierOpt;
non terminal breakStatement, continueStatement;
non terminal returnStatement;

non terminal primary, primaryNoNewArray;
non terminal argumentListOpt, argumentList;
non terminal arrayCreationExpression;
non terminal dimExprs, dimExpr, dimsOpt, dims;
non terminal fieldAccess, methodInvocation, arrayAccess;
non terminal postfixExpression;
non terminal postincrementExpression, postdecrementExpression;
non terminal unaryExpression, unaryExpressionNotPlusMinus;
non terminal preincrementExpression, predecrementExpression;
non terminal multiplicativeExpression, additiveExpression;
non terminal relationalExpression, equalityExpression;
non terminal conditionalAndExpression, conditionalOrExpression;
non terminal conditionalExpression, assignmentExpression;
non terminal assignment;
non terminal leftHandSide;
non terminal assignmentOperator;
non terminal expressionOpt, expression;
non terminal constantExpression;
non terminal globalVariable;
non terminal globalVariables;
non terminal methodStatementsOpt;
non terminal servoType;
non terminal servoInitializer;
non terminal servoInitializers;
non terminal robotType;
non terminal delayInitializer;

start with program;


program ::=	compilationUnit:cu
	;

literal ::=	INTEGER_LITERAL
	|	FLOATING_POINT_LITERAL
	|	BOOLEAN_LITERAL
	|	NULL_LITERAL
    |	STRING_LITERAL
	;

type	::=	primitiveType
	|	referenceType
	;
primitiveType ::=
		numericType
	|   SERVO
	|	BOOLEAN
	;
numericType::=	integralType
	|	floatingPointType
	;
integralType ::=
	INT
	;
floatingPointType ::=
	DOUBLE
	;

referenceType ::=  arrayType
    | robotType
    | servoType
    | name
	;

servoType ::= SERVOPOSITION;

robotType ::= ROBOT;

arrayType ::=	primitiveType dims
	|	name dims
	;

name	::=	simpleName
	|	qualifiedName
	;
simpleName ::=	IDENTIFIER
	;
qualifiedName ::=
		name DOT IDENTIFIER
	;

compilationUnit ::= globalVariables:gl methodStatementsOpt:mso
    | methodStatementsOpt;


globalVariables ::= globalVariable
    | globalVariables globalVariable
    ;

globalVariable ::= localVariableDeclarationStatement;

methodStatementsOpt ::= methodStatements | ;

methodStatements ::=
        methodDeclaration
    |   methodStatements methodDeclaration
    ;

variableDeclarators ::=
	    variableDeclarator
	|	variableDeclarators COMMA variableDeclarator
	;
variableDeclarator ::=
		variableDeclaratorId
	|	variableDeclaratorId EQ variableInitializer
	;
variableDeclaratorId ::=
		IDENTIFIER
	|	variableDeclaratorId LBRACK RBRACK
	;
variableInitializer ::=
		expression
	|	arrayInitializer
	|   servoInitializer
	;

methodDeclaration ::=
		methodHeader methodBody
	;
methodHeader ::=
	    type methodDeclarator
	|	VOID methodDeclarator
	;
methodDeclarator ::=
		IDENTIFIER LPAREN formalParameterListOpt RPAREN
	|	methodDeclarator LBRACK RBRACK
	;
formalParameterListOpt ::=
	|	formalParameterList
	;
formalParameterList ::=
		formalParameter
	|	formalParameterList COMMA formalParameter
	;
formalParameter ::=
		type variableDeclaratorId
	|	CONST type variableDeclaratorId
	;

methodBody ::=	block
	|	SEMICOLON
	;

arrayInitializer ::=
		LBRACE variableInitializers COMMA RBRACE
	|	LBRACE variableInitializers RBRACE
	|	LBRACE COMMA RBRACE
	|	LBRACE RBRACE
	;

servoInitializers ::= IDENTIFIER COLON literal
    |   servoInitializers COMMA IDENTIFIER COLON literal
    ;

servoInitializer ::=
        LBRACE servoInitializers RBRACE
    ;

variableInitializers ::=
		variableInitializer
	|	variableInitializers COMMA variableInitializer
	;

block ::=	BEGIN blockStatementsOpt END
	;

blockStatementsOpt ::=
	|	blockStatements
	;

blockStatements ::=
		blockStatement
	|	blockStatements blockStatement
	;

blockStatement ::=
		localVariableDeclarationStatement
	|	statement
	;

localVariableDeclarationStatement ::=
		localVariableDeclaration SEMICOLON
	;

localVariableDeclaration ::=
		type variableDeclarators
	|	CONST type variableDeclarators
	;

statement ::=
        statementWithoutTrailingSubstatement
	|	ifThenStatement
	|	ifThenElseStatement
	|	whileStatement
	|	forStatement
	;

statementNoShortIf ::=
		statementWithoutTrailingSubstatement
	|	ifThenElseStatementNoShortIf
	|	whileStatementNoShortIf
	|	forStatementNoShortIf
	;

statementWithoutTrailingSubstatement ::=
		block
	|	emptyStatement
	|	expressionStatement
	|	switchStatement
	|	breakStatement
	|	continueStatement
	|	returnStatement
	;

emptyStatement ::=
		SEMICOLON
	;

expressionStatement ::=
		statementExpression SEMICOLON
	;

statementExpression ::=
		assignment
	|	preincrementExpression
	|	predecrementExpression
	|	postincrementExpression
	|	postdecrementExpression
	|	methodInvocation
	;

ifThenStatement ::=
		IF LPAREN expression RPAREN statement
	;

ifThenElseStatement ::=
		IF LPAREN expression RPAREN statementNoShortIf
			ELSE statement
	;

ifThenElseStatementNoShortIf ::=
		IF LPAREN expression RPAREN statementNoShortIf
			ELSE statementNoShortIf
	;

switchStatement ::=
		SWITCH LPAREN expression RPAREN switchBlock
	;

switchBlock ::=
		BEGIN switchBlockStatementGroups switchLabels END
	|	BEGIN switchBlockStatementGroups END
	|	BEGIN switchLabels END
	|	BEGIN END
	;

switchBlockStatementGroups ::=
		switchBlockStatementGroup
	|	switchBlockStatementGroups switchBlockStatementGroup
	;

switchBlockStatementGroup ::=
		switchLabels blockStatements
	;

switchLabels ::=
		switchLabel
	|	switchLabels switchLabel
	;

switchLabel ::=
		CASE constantExpression COLON
	|	DEFAULT COLON
	;

whileStatement ::=
		WHILE LPAREN expression RPAREN statement
	;
whileStatementNoShortIf ::=
		WHILE LPAREN expression RPAREN statementNoShortIf
	;

forStatement ::=
		FOR LPAREN forInitOpt WHEN expressionOpt THEN
			forUpdateOpt RPAREN statement
	;
forStatementNoShortIf ::=
		FOR LPAREN forInitOpt WHEN expressionOpt THEN
			forUpdateOpt RPAREN statementNoShortIf
	;

forInitOpt ::=
	|	forInit
	;

forInit ::=	statementExpressionList
	|	localVariableDeclaration
	;

forUpdateOpt ::=
	|	forUpdate
	;

forUpdate ::=	statementExpressionList
	;
statementExpressionList ::=
		statementExpression
	|	statementExpressionList COMMA statementExpression
	;

identifierOpt ::=
	|	IDENTIFIER
	;

breakStatement ::=
		BREAK identifierOpt SEMICOLON
	;

returnStatement ::=
		RETURN expressionOpt SEMICOLON
	;

primary ::=	primaryNoNewArray
	|	arrayCreationExpression
	;
primaryNoNewArray ::=
		literal
	|	LPAREN expression RPAREN
	|	fieldAccess
	|	methodInvocation
	|	arrayAccess
	;

argumentListOpt ::=
	|	argumentList
	;

argumentList ::=
		expression
	|	argumentList COMMA expression
	;

arrayCreationExpression ::=
		 primitiveType dimExprs dimsOpt
	|	 primitiveType dims arrayInitializer
	;

dimExprs ::=	dimExpr
	|	dimExprs dimExpr
	;

dimExpr ::=	LBRACK expression RBRACK
	;

dimsOpt ::=
	|	dims
	;

dims ::=	LBRACK RBRACK
	|	dims LBRACK RBRACK
	;

fieldAccess ::=
		primary DOT IDENTIFIER
	;

methodInvocation ::=
		name LPAREN argumentListOpt RPAREN
	;

arrayAccess ::=
		name LBRACK expression RBRACK
	|	primaryNoNewArray LBRACK expression RBRACK
	;

postfixExpression ::=
		primary
	|	name
	|	postincrementExpression
	|	postdecrementExpression
	;

postincrementExpression ::=
		postfixExpression PLUSPLUS
	;

postdecrementExpression ::=
		postfixExpression MINUSMINUS
	;

unaryExpression ::=
		preincrementExpression
	|	predecrementExpression
	|	PLUS unaryExpression
	|	MINUS unaryExpression
	|	unaryExpressionNotPlusMinus
	;

preincrementExpression ::=
		PLUSPLUS unaryExpression
	;

predecrementExpression ::=
		MINUSMINUS unaryExpression
	;

unaryExpressionNotPlusMinus ::=
		postfixExpression
	|	COMP unaryExpression
	|	NOT unaryExpression
	;

multiplicativeExpression ::=
		unaryExpression
	|	multiplicativeExpression MULT unaryExpression
	|	multiplicativeExpression DIV unaryExpression
	|	multiplicativeExpression MOD unaryExpression
	;
additiveExpression ::=
		multiplicativeExpression
	|	additiveExpression PLUS multiplicativeExpression
	|	additiveExpression MINUS multiplicativeExpression
	;

relationalExpression ::=
		additiveExpression
	|	relationalExpression LT additiveExpression
	|	relationalExpression GT additiveExpression
	|	relationalExpression LTEQ additiveExpression
	|	relationalExpression GTEQ additiveExpression
	;

equalityExpression ::=
		relationalExpression
	|	equalityExpression EQEQ relationalExpression
	|	equalityExpression NOTEQ relationalExpression
	;

conditionalAndExpression ::=
		equalityExpression
	|	conditionalAndExpression ANDAND equalityExpression
	;

conditionalOrExpression ::=
		conditionalAndExpression
	|	conditionalOrExpression OROR conditionalAndExpression
	;

conditionalExpression ::=
		conditionalOrExpression
	|	conditionalOrExpression QUESTION expression
			COLON conditionalExpression
	;

assignmentExpression ::=
		conditionalExpression
	|	assignment
	;

assignment ::=	leftHandSide assignmentOperator assignmentExpression
	;

leftHandSide ::=
		name
	|	fieldAccess
	|	arrayAccess
	;

assignmentOperator ::=
		EQ
	|	MULTEQ
	|	DIVEQ
	|	MODEQ
	|	PLUSEQ
	|	MINUSEQ
	;

expressionOpt ::=
	|	expression
	;

expression ::=	assignmentExpression
	;

constantExpression ::=
		expression
	;
