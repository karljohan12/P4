import java_cup.runtime.*;
import AST.Abstract.*;
import AST.NonAbstract.Node.*;

parser code  {:
  public void report_error(String message, Object info) {
    StringBuilder m = new StringBuilder("Error ");

    if (info instanceof java_cup.runtime.Symbol)
      m.append( "("+info.toString()+")" );

    m.append(" : "+message);

    System.out.println(m);
  }

  public void report_fatal_error(String message, Object info) {
    report_error(message, info);
    throw new RuntimeException("Fatal Syntax Error");
  }
:};

terminal BOOLEAN;
terminal INT;
terminal DOUBLE;
terminal CONST;
terminal LBRACE, RBRACE, LBRACK, RBRACK;
terminal SEMICOLON, MULT, COMMA, EQ, LPAREN, RPAREN, COLON;
terminal BEGIN;
terminal END;
terminal VOID;
terminal DEFAULT;
terminal IF, ELSE;
terminal SWITCH;
terminal CASE;
terminal WHILE;
terminal FOR;
terminal BREAK;
terminal RETURN;
terminal PLUSPLUS;
terminal MINUSMINUS;
terminal PLUS, MINUS, NOT, DIV, MOD;
terminal LT, GT, LTEQ, GTEQ;
terminal EQEQ, NOTEQ;
terminal ANDAND;
terminal OROR;
terminal QUESTION;
terminal PLUSEQ, MINUSEQ;
terminal WHEN, THEN;
terminal ROBOT, SERVOPOSITION, SERVO;

terminal Integer INTEGER_LITERAL;
terminal double FLOATING_POINT_LITERAL;
terminal java.lang.Boolean BOOLEAN_LITERAL;
terminal java.lang.String IDENTIFIER;
terminal java.lang.String STRING_LITERAL;
terminal NULL_LITERAL;



non terminal Program program;
non terminal literal;


non terminal type;
non terminal primitiveType;
non terminal numericType;
non terminal referenceType;
non terminal arrayType;

non terminal Identifier name;
non terminal initial;
non terminal FunctionStatementList functionStatements;

non terminal VariableDeclarationList variableDeclarations;
non terminal variableDeclaration;
non terminal variableInitial;

non terminal FunctionHeaderBody functionDeclaration;
non terminal functionHeader;
non terminal functionDeclarator;
non terminal FormalParamList formalParameterList;
non terminal formalParameter;
non terminal functionBody;

non terminal arrayInitial;
non terminal VariableInitList variableInitials;

non terminal BlockStmtsOpt block;
non terminal BlockStatementList blockStatements;
non terminal blockStatement;
non terminal LocalVariableDeclStatement localVariableDeclarationstatement;
non terminal localVariableDecl;
non terminal Statement;
non terminal statementIfWithoutElse;
non terminal statementWithoutTrailingSubstatement;
non terminal StmtExpr expressionStatement;
non terminal statementExpression;
non terminal IfLparenExprRparen ifThenStatement;
non terminal IfLparenExprRparenStmtIfWithoutElseElseStmt ifThenElseStmt;
non terminal Switch switchStatement;
non terminal switchBlock;
non terminal switchBlockStatementGroups;
non terminal SwitchLabelBlock switchBlockStatementGroup;
non terminal SwitchLabelList switchLabels;
non terminal switchLabel;
non terminal WhileExpr whileStatement;
non terminal ForExpr forStatement;
non terminal forInitial;
non terminal StatementExpressionsList stmtExprList;
non terminal ReturnStmtExpr returnStatement;

non terminal primary;
non terminal primaryNoNewArray;
non terminal ArgumentList argumentList;
non terminal NameLeftParenthesisArgumentListOptionalRightParenthesis functionCall;
non terminal arrayAccess;
non terminal Expression postfixExpression;
non terminal Expression unaryExpression;
non terminal Expression unaryExprNotPlusMinus;
non terminal Expression mulExpression;
non terminal Expression plusExpression;
non terminal Expression relationalExpression;
non terminal Expression equalExpression;
non terminal Expression conditionalAndExpression;
non terminal Expression conditionalOrExpression;
non terminal Expression conditionalExpression;
non terminal Expression assignmentOrConditionalExpression;
non terminal Expression assignment;
non terminal Expression leftHandSide;
non terminal Expression assignmentOperator;
non terminal Expression expression;
non terminal ConstantExpression constantExpression;
non terminal localVariableDeclStmtGlobal globalVariable;
non terminal GlobalVariableList globalVariables;
non terminal ServoInitsStmt servoInitial;
non terminal servoInitials;



start with program;


program                         ::=	initial:s
                                     // {: RESULT = new Program(s, sleft); :}
                                      {: RESULT = s;:}
                                      ;

literal                         ::=	INTEGER_LITERAL:il
                                      {: RESULT = new IntegerLiteral(il, illeft); :}
	                              |	FLOATING_POINT_LITERAL:fl
	                                  {: RESULT = new FloatLiteral(fl, flleft); :}
	                              |	BOOLEAN_LITERAL:bl
	                                  {: RESULT = new BoolLiteral(bl, blleft); :}
	                              |	NULL_LITERAL: nl
	                                  {: RESULT = new NullLiteral(nl, nlleft); :}
                                  |	STRING_LITERAL:sl
                                      {: RESULT = new StrLiteral(sl, slleft); :};

type	                        ::=	primitiveType:pt
                                      {: RESULT = pt;:}
	                              |	referenceType:rt
	                                  {: RESULT = rt;:};

primitiveType                   ::= numericType:nt
	                            	  {: RESULT = nt;:}
	                              | SERVO:st
	                                  {: RESULT = new ServoPrimitiveType(stleft); :}
	                              |	BOOLEAN:bt
	                                  {: RESULT = new BoolType(btleft); :};

numericType                     ::= INT:it
                                      {: RESULT = new IntType(itleft); :}
	                              |	DOUBLE:ft
	                                  {: RESULT = new FloatType(ftleft); :};

referenceType                   ::= arrayType:at
                                      {: RESULT = at;:}
                                  | ROBOT:rt
                                      {: RESULT = new RobotType(rtleft); :}
                                  | SERVOPOSITION:st
                                      {: RESULT = new ServoType(stleft); :}
                                  | name:n
                                      {: RESULT = n; :};

arrayType                       ::= primitiveType:pt LBRACK RBRACK
                                      {: RESULT = new ArrayType(pt, ptleft); :};

name	                        ::= IDENTIFIER:ident
                                      {: RESULT = new Identifier(ident, identleft); :};

initial                           ::= globalVariables:gvs functionStatements:fso
                                      {: RESULT = new GlobalVariablePlusFunctionStatements(gvs, fso, gvsleft); :}
                                  | functionStatements:fso
                                      {: RESULT = fso; :};


globalVariables                 ::=
                                      {: RESULT = new GlobalVariableList(); :}
                                  | globalVariable:gv
                                      {: GlobalVariableList gvl = new GlobalVariableList();
                                         gvl.add(gv);
                                         RESULT = gvl;
                                      :}
                                  | globalVariables:gvs globalVariable:gv
                                      {: gvl.add(gv);
                                         RESULT = gvs;
                                      :};

globalVariable                  ::= localVariableDeclarationstatement:lvds
                                      {: RESULT = lvds; :};

//functionStmtsOpt                ::= functionStmts:fs
                                      //{: RESULT = new Function(fs, fsleft); :}
  //                                    {: RESULT = fs;:}
    //                              | ;

functionStatements              ::=
                                     {: RESULT = new FunctionStatementList(); :}
                                  | functionDeclaration:fd
                                      {: FunctionStatementList fsl = new FunctionStatementList();
                                         fsl.add(fd);
                                         RESULT = fsl;
                                      :}
                                  | functionStatements:fs functionDeclaration:fd
                                      {: fsl.add(fd);
                                          RESULT = fs;
                                      :};

variableDeclarations                   ::=
                                     {: RESULT = new VariableDeclarationList(); :}
                                  | variableDeclaration:vd
                                      {: VariableDeclarationList vdl = new VariableDeclarationList();
                                         vdl.add(vd);
                                         RESULT = vdl;
                                      :}
	                              |	variableDeclarations:vds COMMA variableDeclaration:vd
	                                  {: vdl.add(vd);
                                         RESULT = vds;
                                      :};

variableDeclaration                    ::= name:vdi
	                                  //{: RESULT = new VariableDeclId(vdi, vdileft); :}
	                                  {: RESULT = vdi;:}
	                              |	name:vdi EQ variableInitial:vi
	                                  {: RESULT = new VariableAssignmentDeclaration(vdi, vi, vdileft); :};

variableInitial                    ::= expression:e
		                              //{: RESULT = new expr(e, eleft); :}
		                              {: RESULT = e; :}
	                              |	arrayInitial:ai
	                                  //{: RESULT = new ArrayInit(ai, aileft); :}
	                                  {: RESULT = ai; :}
	                              | servoInitial:sis
	                                  //{: RESULT = new ServoInitStmt(sis, sisleft); :}
	                                  {: RESULT = sis; :};

functionDeclaration                    ::= functionHeader:fh functionBody:fb
		                              {: RESULT = new Function(fh, fb, fhleft); :};

functionHeader                  ::= type:t functionDeclarator:fd
	                                  {: RESULT = new TypeFunctionHeader(t, fd, fdleft); :}
	                              | VOID functionDeclarator:fd
	                                  {: RESULT = new VoidFunctionHeader(fd, fdleft); :};

functionDeclarator              ::= IDENTIFIER LPAREN formalParameterList:fplo RPAREN
		                              {: RESULT = new FunctionDeclarator(fplo, fploleft); :};

//formalParamListOpt              ::=
//	                              |	formalParamList:fpl
	                                  //{: RESULT = new FormalParamList(fpl, fplleft); :}
//	                                  {: RESULT = fpl;:}
//	                                  	                                  ;

formalParameterList                 ::=
                                    {: RESULT = new FormalParameterList(); :}
                                  | formalParameter:fp
		                              {: FormalParameterList fpl = new FormalParameterList();
                                         fpl.add(fp);
                                         RESULT = fpl;
                                      :}
     	                          | formalParameterList:fpl COMMA formalParameter:fp
    	                              {: flp.add(fp);
                                         RESULT = fpl;
                                      :};

formalParameter                     ::= type:t name:vdi
		                              {: RESULT = new FormalParameter(t, vdi, tleft); :}
	                              | CONST type:t name:vdi
	                                  {: RESULT = new ConstantFormalParameter(t, vdi, tleft); :};

functionBody                    ::= block:b
                                      //{: RESULT = new FunctionBlock(b, bleft); :}
                                      {: RESULT = b; :}
	                              |	SEMICOLON:sc
	                                  //{: RESULT = new SemiColonFunction(scleft); :}
	                                  {: RESULT = sc; :};

arrayInitial                       ::=	LBRACE variableInitials:vi RBRACE
	                                  {: RESULT = new ArrayVariables(vi, vileft); :}
	                              |	LBRACE:lb RBRACE
	                                  {: RESULT = new EmptyArray(lbleft); :};

servoInitials                      ::=
                                      {: RESULT = new ServoInitializationList(); :}
                                  | IDENTIFIER COLON literal:l
                                      {: ServoInitializationList sil = new ServoInitializationList();
                                         sil.add(l);
                                         RESULT = sil;
                                      :}
                                  | servoInitials:si COMMA IDENTIFIER COLON literal:l
                                      {: sil.add(l);
                                         RESULT = si;
                                      :};

servoInitial                       ::= LBRACE servoInitials:si RBRACE
                                      {: RESULT = new ServoPositionVariables(si, sileft); :};

variableInitials                   ::=
                                      {: RESULT = new VariableInitList(); :}
                                  | variableInitial:vi
		                              {: VariableInitList vil = new VariableInitList();
                                        vil.add(vi);
                                      	RESULT = vil;
                                      :}
	                              |	variableInitials:vis COMMA variableInitial:vi
	                                  {: vil.add(vi);
                                         RESULT = vis;
                                      :};

block                           ::= BEGIN blockStatements:bso END
                                      {: RESULT = new Block(bso, bsoleft); :};

//blockStmtsOpt                   ::=
//	                              |	blockStmts:bss
	                                  //{: RESULT = new BlockStmts(bss, bssleft); :}
//                                {: RESULT = bss;:}
	//                                  ;

blockStatements                      ::=
                                      {: RESULT = new BlockStatementList(); :}
                                  | blockStatement:bs
		                              {: BlockStatememtList bsl = new BlockStatementList();
		                                 bsl.add(bs);
		                                 RESULT = bsl;
		                              :}
	                              |	blockStatements:bss blockStatement:bs
                                      {: bsl.add(bs);
                                         RESULT = bss; :};

blockStatement                       ::= localVariableDeclarationstatement:lvds
		                              //{: RESULT = new localVariableDeclBlockStmt(lvds, lvdsleft); :}
		                              {: RESULT = lvds;:}
	                              |	Statement:s
	                                  //{: RESULT = new stmt(s, sleft); :}
	                                  {: RESULT = s;:}
	                                  ;

localVariableDeclarationstatement           ::= localVariableDecl:lvd SEMICOLON
		                              {: RESULT = new LocalVariableDeclarationStatement(lvd, lvdleft); :};

localVariableDecl               ::= type:t variableDeclarations:vds
		                              {: RESULT = new VariableDeclaration(t, vds, vdsleft); :}
	                              |	CONST type:t variableDeclarations:vds
	                                  {: RESULT = new ConstantVariableDeclaration(t, vds, tleft); :};

Statement                            ::= statementWithoutTrailingSubstatement:swtss
                                      {: RESULT = swtss;:}
	                              |	ifThenStatement:its
	                                  {: RESULT = its;:}
	                              |	ifThenElseStmt:ites
	                                  {: RESULT = ites;:}
	                              |	whileStatement:ws
	                                  {: RESULT = ws;:}
	                              |	forStatement:fs
	                                  {: RESULT = fs;:};

statementIfWithoutElse               ::= statementWithoutTrailingSubstatement:swtss
		                              {: RESULT = swtss;:};

statementWithoutTrailingSubstatement ::= block:b
		                              {: RESULT = b; :}
	                              |	SEMICOLON:es
	                                  {: RESULT = es; :}
	                              |	expressionStatement:exs
	                                  {: RESULT = exs; :}
	                              |	switchStatement:ss
	                                  {: RESULT = ss; :}
	                              |	BREAK:b SEMICOLON
                                      {: RESULT = new Break(bleft); :}
	                              |	returnStatement:rs
	                                  {: RESULT = rs; :};

expressionStatement                        ::= statementExpression:se SEMICOLON
		                              {: RESULT = new StatementExpression(se, seleft); :};

statementExpression                        ::= assignment:a
		                              {: RESULT = a; :}
	                              |	PLUSPLUS unaryExpression:ue
                                      {: RESULT = new PlusPlusUnaryExpression(ue, ueleft); :}
	                              |	MINUSMINUS unaryExpression:ue
                                      {: RESULT = new MinusMinusUnaryExpression(ue, ueleft); :}
	                              |	postfixExpression:pe PLUSPLUS
                                      {: RESULT = new postfixExpressionPlusPlus(pe, peleft); :}
                                  |	postfixExpression:pe MINUSMINUS
                                      {: RESULT = new PostfixExpressionMinusMinus(pe, peleft); :}
	                              |	functionCall:fc
	                                  {: RESULT = fc; :};

ifThenStatement                      ::= IF LPAREN expression:e RPAREN Statement:s
		                              {: RESULT = new If(e, s, eleft); :};

ifThenElseStmt                  ::= IF LPAREN expression:e RPAREN statementIfWithoutElse:siwe ELSE Statement:s
			                          {: RESULT = new IfElse(e, siwe, s, eleft); :};


switchStatement                      ::= SWITCH LPAREN expression:e RPAREN switchBlock:sb
		                              {: RESULT = new Switch(e, sb, eleft); :};

switchBlock                     ::= BEGIN switchBlockStatementGroups:sbsgs switchLabels:sl END
		                              {: RESULT = new SwitchBlockLabels(sbsgs, sl, sbsgsleft); :}
	                              |	BEGIN switchBlockStatementGroups:sbsgs END
	                                  {: RESULT = new SwitchGroups(sbsgs, sbsgsleft); :}
	                              |	BEGIN switchLabels:sls END
	                                  {: RESULT = new SwitchLabels(sls, slsleft); :}
	                              |	BEGIN:b END
	                                  {: RESULT = new EmptySwitch(bleft); :};

switchBlockStatementGroups           ::=
                                      {: RESULT = new SwitchGroupList(); :} 
                                  | switchBlockStatementGroup:sbsg
		                              {: SwitchGroupList sgl = new SwitchGroupList();
                                         sgl.add(sbsg);
                                         RESULT = sbgs;
                                      :}
	                              |	switchBlockStatementGroups:sbsgs switchBlockStatementGroup:sbsg
	                                  {:
                                      	 sgl.add(sbgs);
                                         RESULT = sgl;
                                      :};

switchBlockStatementGroup            ::= switchLabels:sls blockStatements:bs
		                              {: RESULT = new SwitchLabelBlock(sls, bs, slsleft); :};

switchLabels                    ::=
                                    {: RESULT = new SwitchLabelList(); :}
                                  | switchLabel:sl
		                              {: SwitchLabelList sll = new SwitchLabelList();
                                         sll.add(sl);
                                         RESULT =  sl;
                                      :}
	                              |	switchLabels:sls switchLabel:sl
	                                  {:
	                                    sll.add(sl);
                                        RESULT = sls;
                                      :};

switchLabel                     ::= CASE constantExpression:cs COLON
		                              {: RESULT = new ConstantExpression(cs, csleft); :}
	                              |	DEFAULT:def COLON
	                                  {: RESULT = new DefaultCase(defleft); :};

whileStatement                       ::= WHILE LPAREN expression:e RPAREN
		                              {: RESULT = new WhileLoop(e, eleft); :};

forStatement                         ::= FOR LPAREN forInitial:fi WHEN expression:e THEN statementExpression:sel RPAREN
			                          {: RESULT = new ForLoop(fi, e, sel, fileft); :};

forInitial                         ::= statementExpression:sel
                                      {: RESULT = sel; :}
	                              |	localVariableDecl:lvd
	                                  {: RESULT = lvd; :};

returnStatement                      ::= RETURN expression:e SEMICOLON
		                              {: RESULT = new ReturnStmtExpr(e, eleft); :};

primary                         ::= primaryNoNewArray:pnna
                                      {: RESULT = pnna;:}
                                    ;

primaryNoNewArray               ::= literal:l
                                      {: RESULT = l; :}
	                              |	LPAREN expression:e RPAREN
	                                  {: RESULT = e; :}
	                              |	functionCall:fc
	                                  {: RESULT = fc; :}
	                              |	arrayAccess:aa
	                                  {: RESULT = aa; :};

argumentList                    ::=
                                      {: RESULT = new ArgumentList(); :}
                                  | expression:e
		                              {: ArguemntList arl = new ArgumentList();
		                                 arl.add(e);
		                                 RESULT = arl;
		                              :}
	                              |	argumentList:al COMMA expression:e
	                                  {: arl.add(e);
	                                     RESULT = al;
	                                  :};

functionCall                    ::= name:n LPAREN argumentList:alo RPAREN
		                              {: RESULT = new FunctionCall(n, alo, nleft); :};

arrayAccess                     ::= name:n LBRACK expression:e RBRACK
		                              {: RESULT = new arrayAccessIndex(n, e, nleft); :}
	                              //|	primaryNoNewArray:pnna LBRACK expression:e RBRACK
	                                //  {: RESULT = new PrimaryNoNewArrayLeftBracketExpressionRightBracket(pnna, e, pnnaleft); :}
	                                  ;

postfixExpression                     ::= primary:p
	                                  {: RESULT = p; :}
	                              |	name:n
	                                  {: RESULT = n; :};

unaryExpression                       ::= MINUS unaryExpression:ue
	                                  {: RESULT = new UnaryExpression(ue, ueleft); :}
	                              |	unaryExprNotPlusMinus:uenpm
	                                  {: RESULT = uenpm; :};

unaryExprNotPlusMinus           ::= postfixExpression:pe
		                              {: RESULT = pe;:}
	                              |	NOT unaryExpression:ue
	                                  {: RESULT = new NotUnaryExpression(ue, ueleft); :};

mulExpression                         ::= unaryExpression:ue
		                              {: RESULT = ue; :}
	                              |	mulExpression:me MULT unaryExpression:ue
	                                  {: RESULT = new MultiplicationExpression(me, ue, meleft); :}
	                              |	mulExpression:me DIV unaryExpression:ue
	                                  {: RESULT = new DivisionExpression(me, ue, meleft); :}
	                              |	mulExpression:me MOD unaryExpression:ue
	                                  {: RESULT = new ModuloExpression(me, ue, meleft); :};

plusExpression                        ::= mulExpression:me
	                                  {: RESULT = me;:}
	                              |	plusExpression:pe PLUS mulExpression:me
	                                  {: RESULT = new PlusExpression(pe, me, peleft); :}
	                              |	plusExpression:pe MINUS mulExpression:me
	                                  {: RESULT = new MinusExpression(pe, me, peleft); :};

relationalExpression                  ::= plusExpression:pe
		                              {: RESULT = pe;:}
	                              |	relationalExpression:re LT plusExpression:pe
	                                  {: RESULT = new LessThan(re, pe, releft); :}
	                              |	relationalExpression:re GT plusExpression:pe
	                                  {: RESULT = new GreaterThan(re, pe, releft); :}
	                              |	relationalExpression:re LTEQ plusExpression:pe
	                                  {: RESULT = new LessThanEqual(re, pe, releft); :}
	                              |	relationalExpression:re GTEQ plusExpression:pe
	                                  {: RESULT = new GreaterThanEqual(re, pe, releft); :};

equalExpression                       ::= relationalExpression:re
		                              {: RESULT = re; :}
	                              |	equalExpression:ee EQEQ relationalExpression:re
	                                  {: RESULT = new EqualExpression(ee, re, eeleft); :}
	                              |	equalExpression:ee NOTEQ relationalExpression:re
	                                  {: RESULT = new NotEqualExpression(ee, re, eeleft); :};

conditionalAndExpression              ::= equalExpression:ee
                                      {: RESULT = ee; :}
	                              |	conditionalAndExpression:cae ANDAND equalExpression:ee
	                                  {: RESULT = new AndExpression(cae, ee, caeleft); :};

conditionalOrExpression               ::= conditionalAndExpression:cae
		                              {: RESULT = cae; :}
	                              |	conditionalOrExpression:coe OROR conditionalAndExpression:cae
	                                  {: RESULT = new OrExpression(coe, cae, coeleft); :};

conditionalExpression                 ::= conditionalOrExpression:coe
                                      {: RESULT = coe;:}
	                              | conditionalOrExpression:coe QUESTION expression:e COLON conditionalExpression:ce
			                          {: RESULT = new TernaryExpression(coe, e, ce, coeleft); :};

assignmentOrConditionalExpression                  ::= conditionalExpression:ce
		                              {: RESULT = ce; :}
	                              | assignment:a
	                                  {: RESULT = a; :};

assignment                      ::=	leftHandSide:lhs assignmentOperator:ao assignmentOrConditionalExpression:ae
                                      {: RESULT = new AssignmentExpression(lhs, ao, ae, lhsleft); :};

leftHandSide                    ::= name:n
		                              {: RESULT = n; :}

	                              |	arrayAccess:aa
	                                  {: RESULT = aa; :};

expression                      ::=	assignmentOrConditionalExpression:ae
                                      {: RESULT = ee; :};

assignmentOperator              ::= EQ:eq
		                              {: RESULT = new Equal(eqleft); :}
	                              |	PLUSEQ:pe
	                                  {: RESULT = new PlusEqual(peleft); :}
	                              |	MINUSEQ:me
	                                  {: RESULT = new MinusEqual(meleft); :};

constantExpression                    ::= expression:e
                                      {: RESULT = e; :};