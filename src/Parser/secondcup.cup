import java_cup.runtime.*;


parser code  {:
  public void report_error(String message, Object info) {
    StringBuilder m = new StringBuilder("Error ");

    if (info instanceof java_cup.runtime.Symbol)
      m.append( "("+info.toString()+")" );

    m.append(" : "+message);

    System.out.println(m);
  }

  public void report_fatal_error(String message, Object info) {
    report_error(message, info);
    throw new RuntimeException("Fatal Syntax Error");
  }
:};

terminal BOOLEAN;
terminal INT;
terminal DOUBLE;
terminal CONST;
terminal LBRACE, RBRACE, LBRACK, RBRACK;
terminal SEMICOLON, MULT, COMMA, EQ, LPAREN, RPAREN, COLON;
terminal BEGIN;
terminal END;
terminal VOID;
terminal DEFAULT;
terminal IF, ELSE;
terminal SWITCH;
terminal CASE;
terminal WHILE;
terminal FOR;
terminal BREAK;
terminal RETURN;
terminal PLUSPLUS;
terminal MINUSMINUS;
terminal PLUS, MINUS, COMP, NOT, DIV, MOD;
terminal LT, GT, LTEQ, GTEQ;
terminal EQEQ, NOTEQ;
terminal ANDAND;
terminal OROR;
terminal QUESTION;
terminal MULTEQ, DIVEQ, MODEQ, PLUSEQ, MINUSEQ;
terminal WHEN, THEN;
terminal ROBOT, SERVOPOSITION, SERVO;

terminal java.lang.Number INTEGER_LITERAL;
terminal java.lang.Number FLOATING_POINT_LITERAL;
terminal java.lang.Boolean BOOLEAN_LITERAL;
terminal java.lang.String IDENTIFIER;
terminal java.lang.String STRING_LITERAL;
terminal NULL_LITERAL;



non terminal program;
non terminal literal;


non terminal type, primitiveType, numericType;
non terminal integerType, floatType;
non terminal referenceType;
non terminal arrayType;

non terminal name;
non terminal Start;
non terminal functionStmts;

non terminal variableDecls, variableDecl;
non terminal variableDeclId, variableInit;

non terminal functionDecl, functionHeader, functionDeclerator;
non terminal formalParamListOpt, formalParamList;
non terminal formalParam;
non terminal functionBody;

non terminal arrayInit;
non terminal variableInits;

non terminal block;
non terminal blockStmtsOpt, blockStmts, blockStmt;
non terminal localVariableDeclStmt, localVariableDecl;
non terminal stmt, stmtIfWithoutElse;
non terminal stmtWithoutTrailingSubstatement;
non terminal emptyStmt;
non terminal exprStmt, stmtExpr;
non terminal ifThenStmt;
non terminal ifThenElseStmt, ifThenElseIfWithoutElse;
non terminal switchStmt, switchBlock;
non terminal switchBlockStmtGroups;
non terminal switchBlockStmtGroup;
non terminal switchLabels, switchLabel;
non terminal whileStmt;
non terminal forStmt;
non terminal forInit;
non terminal stmtExprList;
non terminal breakStmt, continueStatement;
non terminal returnStmt;

non terminal primary, primaryNoNewArray;
non terminal argumentListOpt, argumentList;
non terminal arrayCreationExpr;
non terminal bracketEnclosureExprs, bracketEnclosureExpr, bracketEnclosureOpt, bracketEnclosure;
non terminal functionCall, arrayAccess;
non terminal postfixExpr;
non terminal postincrementExpr, postdecrementExpr;
non terminal unaryExpr, unaryExprNotPlusMinus;
non terminal preincrementExpr, predecrementExpr;
non terminal mulExpr, plusExpr;
non terminal relationalExpr, equalExpr;
non terminal conditionalAndExpr, conditionalOrExpr;
non terminal conditionalExpr, assignmentExpr;
non terminal assignment;
non terminal leftHandSide;
non terminal assignmentOperator;
non terminal expr;
non terminal constantExpr;
non terminal globalVariable;
non terminal globalVariables;
non terminal functionStmtsOpt;
non terminal servoType;
non terminal servoInit;
non terminal servoInits;
non terminal robotType;


start with program;


program ::=	Start:cu
	;

literal ::=	INTEGER_LITERAL
	|	FLOATING_POINT_LITERAL
	|	BOOLEAN_LITERAL
	|	NULL_LITERAL
    |	STRING_LITERAL
	;

type	::=	primitiveType
	|	referenceType
	;
primitiveType ::=
		numericType
	|   SERVO
	|	BOOLEAN
	;
numericType::=	integerType
	|	floatType
	;
integerType ::=
	INT
	;
floatType ::=
	DOUBLE
	;

referenceType ::=  arrayType
    | robotType
    | servoType
    | name
	;

servoType ::= SERVOPOSITION;

robotType ::= ROBOT;

arrayType ::=	primitiveType bracketEnclosure
	|	name bracketEnclosure
	;

name	::= IDENTIFIER

	;

Start ::= globalVariables:gl functionStmtsOpt:mso
    | functionStmtsOpt;


globalVariables ::= globalVariable
    | globalVariables globalVariable
    ;

globalVariable ::= localVariableDeclStmt;

functionStmtsOpt ::= functionStmts | ;

functionStmts ::=
        functionDecl
    |   functionStmts functionDecl
    ;

variableDecls ::=
	    variableDecl
	|	variableDecls COMMA variableDecl
	;
variableDecl ::=
		variableDeclId
	|	variableDeclId EQ variableInit
	;
variableDeclId ::=
		IDENTIFIER
	|	variableDeclId LBRACK RBRACK
	;
variableInit ::=
		expr
	|	arrayInit
	|   servoInit
	;

functionDecl ::=
		functionHeader functionBody
	;
functionHeader ::=
	    type functionDeclerator
	|	VOID functionDeclerator
	;
functionDeclerator ::=
		IDENTIFIER LPAREN formalParamListOpt RPAREN
	|	functionDeclerator LBRACK RBRACK
	;
formalParamListOpt ::=
	|	formalParamList
	;
formalParamList ::=
		formalParam
	|	formalParamList COMMA formalParam
	;
formalParam ::=
		type variableDeclId
	|	CONST type variableDeclId
	;

functionBody ::=	block
	|	SEMICOLON
	;

arrayInit ::=
		LBRACE variableInits COMMA RBRACE
	|	LBRACE variableInits RBRACE
	|	LBRACE COMMA RBRACE
	|	LBRACE RBRACE
	;

servoInits ::= IDENTIFIER COLON literal
    |   servoInits COMMA IDENTIFIER COLON literal
    ;

servoInit ::=
        LBRACE servoInits RBRACE
    ;

variableInits ::=
		variableInit
	|	variableInits COMMA variableInit
	;

block ::=	BEGIN blockStmtsOpt END
	;

blockStmtsOpt ::=
	|	blockStmts
	;

blockStmts ::=
		blockStmt
	|	blockStmts blockStmt
	;

blockStmt ::=
		localVariableDeclStmt
	|	stmt
	;

localVariableDeclStmt ::=
		localVariableDecl SEMICOLON
	;

localVariableDecl ::=
		type variableDecls
	|	CONST type variableDecls
	;

stmt ::=
        stmtWithoutTrailingSubstatement
	|	ifThenStmt
	|	ifThenElseStmt
	|	whileStmt
	|	forStmt
	;

stmtIfWithoutElse ::=
		stmtWithoutTrailingSubstatement
	|	ifThenElseIfWithoutElse
	;

stmtWithoutTrailingSubstatement ::=
		block
	|	emptyStmt
	|	exprStmt
	|	switchStmt
	|	breakStmt
	|	continueStatement
	|	returnStmt
	;

emptyStmt ::=
		SEMICOLON
	;

exprStmt ::=
		stmtExpr SEMICOLON
	;

stmtExpr ::=
		assignment
	|	preincrementExpr
	|	predecrementExpr
	|	postincrementExpr
	|	postdecrementExpr
	|	functionCall
	;

ifThenStmt ::=
		IF LPAREN expr RPAREN stmt
	;

ifThenElseStmt ::=
		IF LPAREN expr RPAREN stmtIfWithoutElse
			ELSE stmt
	;

ifThenElseIfWithoutElse ::=
		IF LPAREN expr RPAREN stmtIfWithoutElse
			ELSE stmtIfWithoutElse
	;

switchStmt ::=
		SWITCH LPAREN expr RPAREN switchBlock
	;

switchBlock ::=
		BEGIN switchBlockStmtGroups switchLabels END
	|	BEGIN switchBlockStmtGroups END
	|	BEGIN switchLabels END
	|	BEGIN END
	;

switchBlockStmtGroups ::=
		switchBlockStmtGroup
	|	switchBlockStmtGroups switchBlockStmtGroup
	;

switchBlockStmtGroup ::=
		switchLabels blockStmts
	;

switchLabels ::=
		switchLabel
	|	switchLabels switchLabel
	;

switchLabel ::=
		CASE constantExpr COLON
	|	DEFAULT COLON
	;

whileStmt ::=
		WHILE LPAREN expr RPAREN
	;

forStmt ::=
		FOR LPAREN forInit WHEN expr THEN
			stmtExprList RPAREN
	;

forInit ::=	stmtExprList
	|	localVariableDecl
	;

stmtExprList ::=
		stmtExpr
	|	stmtExprList COMMA stmtExpr
	;

breakStmt ::=
		BREAK SEMICOLON
	;

returnStmt ::=
		RETURN expr SEMICOLON
	;

primary ::=	primaryNoNewArray
	|	arrayCreationExpr
	;
primaryNoNewArray ::=
		literal
	|	LPAREN expr RPAREN
	|	functionCall
	|	arrayAccess
	;

argumentListOpt ::=
	|	argumentList
	;

argumentList ::=
		expr
	|	argumentList COMMA expr
	;

arrayCreationExpr ::=
		 primitiveType bracketEnclosureExprs bracketEnclosureOpt
	|	 primitiveType bracketEnclosure arrayInit
	;

bracketEnclosureExprs ::=	bracketEnclosureExpr
	|	bracketEnclosureExprs bracketEnclosureExpr
	;

bracketEnclosureExpr ::=	LBRACK expr RBRACK
	;

bracketEnclosureOpt ::=
	|	bracketEnclosure
	;

bracketEnclosure ::=	LBRACK RBRACK
	|	bracketEnclosure LBRACK RBRACK
	;

functionCall ::=
		name LPAREN argumentListOpt RPAREN
	;

arrayAccess ::=
		name LBRACK expr RBRACK
	|	primaryNoNewArray LBRACK expr RBRACK
	;

postfixExpr ::=
		primary
	|	name
	|	postincrementExpr
	|	postdecrementExpr
	;

postincrementExpr ::=
		postfixExpr PLUSPLUS
	;

postdecrementExpr ::=
		postfixExpr MINUSMINUS
	;

unaryExpr ::=
		preincrementExpr
	|	predecrementExpr
	|	PLUS unaryExpr
	|	MINUS unaryExpr
	|	unaryExprNotPlusMinus
	;

preincrementExpr ::=
		PLUSPLUS unaryExpr
	;

predecrementExpr ::=
		MINUSMINUS unaryExpr
	;

unaryExprNotPlusMinus ::=
		postfixExpr
	|	COMP unaryExpr
	|	NOT unaryExpr
	;

mulExpr ::=
		unaryExpr
	|	mulExpr MULT unaryExpr
	|	mulExpr DIV unaryExpr
	|	mulExpr MOD unaryExpr
	;
plusExpr ::=
		mulExpr
	|	plusExpr PLUS mulExpr
	|	plusExpr MINUS mulExpr
	;

relationalExpr ::=
		plusExpr
	|	relationalExpr LT plusExpr
	|	relationalExpr GT plusExpr
	|	relationalExpr LTEQ plusExpr
	|	relationalExpr GTEQ plusExpr
	;

equalExpr ::=
		relationalExpr
	|	equalExpr EQEQ relationalExpr
	|	equalExpr NOTEQ relationalExpr
	;

conditionalAndExpr ::=
		equalExpr
	|	conditionalAndExpr ANDAND equalExpr
	;

conditionalOrExpr ::=
		conditionalAndExpr
	|	conditionalOrExpr OROR conditionalAndExpr
	;

conditionalExpr ::=
		conditionalOrExpr
	|	conditionalOrExpr QUESTION expr
			COLON conditionalExpr
	;

assignmentExpr ::=
		conditionalExpr
	|	assignment
	;

assignment ::=	leftHandSide assignmentOperator assignmentExpr
	;

leftHandSide ::=
		name
	|	arrayAccess
	;

expr ::=	assignmentExpr
	;

assignmentOperator ::=
		EQ
	|	MULTEQ
	|	DIVEQ
	|	MODEQ
	|	PLUSEQ
	|	MINUSEQ
	;

constantExpr ::=
		expr
	;

